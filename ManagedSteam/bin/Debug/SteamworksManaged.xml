<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SteamworksManaged</name>
    </assembly>
    <members>
        <member name="M:ManagedSteam.IApps.GetCurrentGameLanguage">
            <summary>
            Returns a string with the current game language
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IApps.IsSubscribedApp(ManagedSteam.SteamTypes.AppID)">
            <summary>
            Only use this member if you need to check ownership of another game related to yours, a demo for example
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ManagedSteam.IApps.IsDlcInstalled(ManagedSteam.SteamTypes.AppID)" -->
        <member name="M:ManagedSteam.IApps.GetEarliestPurchaseUnixTime(ManagedSteam.SteamTypes.AppID)">
            <summary>
            Returns the Unix time of the purchase of the app
            </summary>
            <param name="appID"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IApps.IsSubscribedFromFreeWeekend">
            <summary>
            Checks if the user is subscribed to the current app through a free weekend
            This function will return false for users who have a retail or other type of license
            Before using, please ask your Valve technical contact how to package and secure your free weekened
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IApps.GetDLCCount">
            <summary>
            Returns the number of DLC pieces for the running app
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IApps.GetDLCDataByIndex(System.Int32,ManagedSteam.SteamTypes.AppID@,System.Boolean@,System.String@)">
            <summary>
            Returns metadata for DLC by index, of range [0, GetDLCCount()]
            </summary>
            <param name="iDLC">DLC index for the running app</param>
            <param name="pAppID">Contains AppID for the DLC upon return</param>
            <param name="pbAvailable">Contains whether the DLC is available to the client or not (true if the client owns the DLC) upon return</param>
            <param name="pchName">Contains name for DLC upon return</param>
            <returns>True if call was successful</returns>
        </member>
        <member name="M:ManagedSteam.IApps.GetDLCDataByIndex(System.Int32)">
            <summary>
            Returns metadata for DLC by index, of range [0, GetDLCCount()]
            </summary>
            <param name="iDLC">DLC index for current AppID</param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IApps.InstallDLC(ManagedSteam.SteamTypes.AppID)">
            <summary>
            Install control for optional DLC
            </summary>
            <param name="appID"></param>
        </member>
        <member name="M:ManagedSteam.IApps.UninstallDLC(ManagedSteam.SteamTypes.AppID)">
            <summary>
            Uninstall control for optional DLC
            </summary>
            <param name="appID"></param>
        </member>
        <member name="M:ManagedSteam.IApps.RequestAppProofOfPurchaseKey(ManagedSteam.SteamTypes.AppID)">
            <summary>
            Request cd-key for yourself or owned DLC. If you are interested in this
            data then make sure you provide us with a list of valid keys to be distributed
            to users when they purchase the game, before the game ships.
            You'll receive an AppProofOfPurchaseKeyResponse_t callback when
            the key is available (which may be immediately).
            </summary>
            <param name="appID"></param>
        </member>
        <member name="M:ManagedSteam.IApps.GetCurrentBetaName(System.String@)">
            <summary>
            Returns current beta branch name, 'public' is the default branch
            </summary>
            <param name="pchName"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IApps.GetCurrentBetaName">
            <summary>
            Returns struct containing current beta branch name and bool result for original function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IApps.MarkContentCorrupt(System.Boolean)">
            <summary>
            Signal Steam that game files seems corrupt or missing
            </summary>
            <param name="bMissingFilesOnly"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IApps.GetInstalledDepots(ManagedSteam.SteamTypes.AppID,ManagedSteam.SteamTypes.DepotID@,System.UInt32)">
            <summary>
            Return installed depots in mount order
            </summary>
            <param name="appID"></param>
            <param name="pDepotID"></param>
            <param name="maxDepots"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IApps.GetAppOwner">
            <summary>
            Returns the SteamID of the original owner. If different from current user, it's borrowed
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ManagedSteam.IApps.GetLaunchQueryParam(System.String)" -->
        <member name="T:ManagedSteam.CallbackStructures.PersonaStateChange">
            <summary>
            called when a friends' status changes
            
            Wrapper for the \steamref PersonaStateChange_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.PersonaStateChange.SteamID">
            <summary>
            steamID of the friend who changed
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.PersonaStateChange.ChangeFlags">
            <summary>
            what's changed
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GameOverlayActivated">
            <summary>
            posted when game overlay activates or deactivates.
            the game can use this to be pause or resume single player games
            		
            Wrapper for the \steamref GameOverlayActivated_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GameOverlayActivated.Active">
            <summary>
            true if it's just been activated, false otherwise
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GameServerChangeRequested">
            <summary>
            called when the user tries to join a different game server from their friends list.
            game client should attempt to connect to specified server when this is received
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GameServerChangeRequested.Server">
            <summary>
            server address ("127.0.0.1:27015", "tf2.valvesoftware.com")
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GameServerChangeRequested.Password">
            <summary>
            server password, if any
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GameLobbyJoinRequested">
             <summary>
             called when the user tries to join a lobby from their friends list.
             game client should attempt to connect to specified lobby when this is received
            
             Wrapper for the \steamref GameLobbyJoinRequested_t struct
             </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GameLobbyJoinRequested.FriendID">
            <summary>
            The friend they did the join via (will be invalid if not directly via a friend)
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.AvatarImageLoaded">
             <summary>
             called when an avatar is loaded in from a previous GetLargeFriendAvatar() call.
             if the image wasn't already available
            
             Wrapper for the \steamref AvatarImageLoaded_t struct
             </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.AvatarImageLoaded.SteamID">
            <summary>
            steamid the avatar has been loaded for
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.AvatarImageLoaded.Image">
            <summary>
            the image index of the now loaded image
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.AvatarImageLoaded.Width">
            <summary>
            width of the loaded image
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.AvatarImageLoaded.Height">
            <summary>
            height of the loaded image
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.ClanOfficerListResponse">
            <summary>
            marks the return of a request officer list call
            
            Wrapper for the \steamref ClanOfficerListResponse_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.FriendRichPresenceUpdate">
            <summary>
            callback indicating updated data about friends rich presence information
               
            Wrapper for the \steamref FriendRichPresenceUpdate_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.FriendRichPresenceUpdate.SteamIDFriend">
            <summary>
            friend who's rich presence has changed
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.FriendRichPresenceUpdate.GameAppID">
            <summary>
            the appID of the game (should always be the current game)
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GameRichPresenceJoinRequested">
            <summary>
            called when the user tries to join a game from their friends list.
            rich presence will have been set with the "connect" key which is set here
            		
            Wrapper for the \steamref GameRichPresenceJoinRequested_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GameRichPresenceJoinRequested.SteamIDFriend">
            <summary>
            the friend they did the join via (will be invalid if not directly via a friend)
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GameConnectedClanChatMsg">
            <summary>
            a chat message has been received for a clan chat the game has joined
               
            Wrapper for the \steamref GameConnectedClanChatMsg_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GameConnectedChatJoin">
            <summary>
            a user has joined a clan chat
            
            Wrapper for the \steamref GameConnectedChatJoin_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GameConnectedChatLeave">
            <summary>
            a user has left the chat we're in
            
            Wrapper for the \steamref GameConnectedChatLeave_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GameConnectedChatLeave.Kicked">
            <summary>
            true if admin kicked
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GameConnectedChatLeave.Dropped">
            <summary>
            true if Steam connection dropped
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.DownloadClanActivityCountsResult">
            <summary>
            a DownloadClanActivityCounts() call has finished
            
            Wrapper for the \steamref DownloadClanActivityCountsResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.JoinClanChatRoomCompletionResult">
            <summary>
            a JoinClanChatRoom() call has finished
            
            Wrapper for the \steamref JoinClanChatRoomCompletionResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GameConnectedFriendChatMsg">
            <summary>
            a chat message has been received from a user
            
            Wrapper for the \steamref GameConnectedFriendChatMsg_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.FriendsGetFollowerCount">
            <summary>
            Wrapper for the \steamref FriendsGetFollowerCount_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.FriendsIsFollowing">
            <summary>
            Wrapper for the \steamref FriendsIsFollowing_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.FriendsEnumerateFollowingList">
            <summary>
            Wrapper for the \steamref FriendsEnumerateFollowingList_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSClientApprove">
            <summary>
            Client has been approved to connect to this game server
            
            Wrapper for the \steamref GSClientApprove_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSClientDeny">
            <summary>
            Client has been denied to connection to this game server
            
            Wrapper for the \steamref GSClientDeny_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSClientKick">
            <summary>
            request the game server should kick the user
            
            Wrapper for the \steamref GSClientKick_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSClientAchievementStatus">
            <summary>
            client achievement info
            
            Wrapper for the \steamref GSClientAchievementStatus_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSPolicyResponse">
            <summary>
            received when the game server requests to be displayed as secure (VAC protected)
            Secure is true if the game server should display itself as secure to users, false otherwise
            
            Wrapper for the \steamref GSPolicyResponse_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSGameplayStats">
            <summary>
            GS gameplay stats info
            
            Wrapper for the \steamref GSGameplayStats_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSGameplayStats.Result">
            <summary>
            Result of the call
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSGameplayStats.Rank">
            <summary>
            Overall rank of the server (0-based)
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSGameplayStats.TotalConnects">
            <summary>
            Total number of clients who have ever connected to the server
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSGameplayStats.TotalMinutesPlayed">
            <summary>
            Total number of minutes ever played on the server
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSClientGroupStatus">
            <summary>
            send as a reply to RequestUserGroupStatus()
            
            Wrapper for the \steamref GSClientGroupStatus_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSReputation">
            <summary>
            Sent as a reply to GetServerReputation()
            
            Wrapper for the \steamref GSReputation_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSReputation.Result">
            <summary>
            Result of the call;
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSReputation.ReputationScore">
            <summary>
            The reputation score for the game server
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSReputation.Banned">
            <summary>
            True if the server is banned from the Steam master servers
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSReputation.BannedIP">
            <summary>
            The following members are only filled out if m_bBanned is true. They will all 
            be set to zero otherwise. Master server bans are by IP so it is possible to be
            banned even when the score is good high if there is a bad server on another port.
            This information can be used to determine which server is bad.
            
            The IP of the banned server
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSReputation.BannedPort">
            <summary>
            The port of the banned server
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSReputation.BannedGameID">
            <summary>
            The game ID the banned server is serving
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.GSReputation.BanExpires">
            <summary>
            Time the ban expires, expressed in the Unix epoch (seconds since 1/1/1970)
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.AssociateWithClanResult">
            <summary>
            Sent as a reply to AssociateWithClan()
            
            Wrapper for the \steamref AssociateWithClanResult_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.AssociateWithClanResult.Result">
            <summary>
            Result of the call;
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.ComputeNewPlayerCompatibilityResult">
            <summary>
            Sent as a reply to ComputeNewPlayerCompatibility()
            
            Wrapper for the \steamref ComputeNewPlayerCompatibilityResult_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.ComputeNewPlayerCompatibilityResult.Result">
            <summary>
            Result of the call
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSStatsReceived">
            <summary>
            Wrapper for the \a GSStatsRecieved_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSStatsStored">
            <summary>
            Wrapper for the \a GSStatsStored_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GSStatsUnloaded">
            <summary>
            Wrapper for the \a GSStatsUnloaded_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.HTTPRequestCompleted.Request">
            <summary>
            Handle value for the request that has completed.
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.HTTPRequestCompleted.ContextValue">
            <summary>
            Context value that the user defined on the request that this callback is associated with, 0 if
            no context value was set.
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.HTTPRequestCompleted.RequestSuccessful">
            <summary>
            This will be true if we actually got any sort of response from the server (even an error).  
            It will be false if we failed due to an internal error or client side network failure.
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.HTTPRequestCompleted.StatusCode">
            <summary>
            Will be the HTTP status code value returned by the server, k_EHTTPStatusCode200OK is the normal
            OK response, if you get something else you probably need to treat it as a failure.
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.HTTPRequestHeadersReceived.Request">
            <summary>
            Handle value for the request that has received headers.
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.HTTPRequestHeadersReceived.ContextValue">
            <summary>
            Context value that the user defined on the request that this callback is associated with, 0 if
            no context value was set.
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.HTTPRequestDataReceived.Request">
            <summary>
            Handle value for the request that has received data.
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.HTTPRequestDataReceived.ContextValue">
            <summary>
            Context value that the user defined on the request that this callback is associated with, 0 if no context value was set.
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.HTTPRequestDataReceived.Offset">
            <summary>
            Offset to provide to GetHTTPStreamingResponseBodyData to get this chunk of data
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.HTTPRequestDataReceived.BytesReceived">
            <summary>
            Size to provide to GetHTTPStreamingResponseBodyData to get this chunk of data
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.FavoritesListChanged">
            <summary>
            a server was added/removed from the favorites list, you should refresh now
            
            Wrapper for the \steamref FavoritesListChanged_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.FavoritesListChanged.IP">
            <summary>
            an IP of 0 means reload the whole list, any other value means just one server
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.FavoritesListChanged.Add">
            <summary>
            true if this is adding the entry, otherwise it is a remove
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ManagedSteam.CallbackStructures.LobbyInvite" -->
        <member name="T:ManagedSteam.CallbackStructures.LobbyEnter">
            <summary>
            Sent on entering a lobby, or on failing to enter
            ChatRoomEnterResponse will be set to Success on success,
            or a higher value on failure (see enum ChatRoomEnterResponse)
            
            Wrapper for the \a LobbyEnter_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyEnter.SteamIDLobby">
            <summary>
            SteamID of the Lobby you have entered
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyEnter.ChatPermissions">
            <summary>
            Permissions of the current user
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyEnter.Locked">
            <summary>
            If true, then only invited users may join
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyEnter.ChatRoomEnterResponse">
            <summary>
            EChatRoomEnterResponse
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LobbyDataUpdate">
            <summary>
            The lobby metadata has changed
            
            if m_ulSteamIDMember is the steamID of a lobby member, use GetLobbyMemberData() to access per-user details
            
            if m_ulSteamIDMember == m_ulSteamIDLobby, use GetLobbyData() to access lobby metadata
            
            Wrapper for the \a LobbyDataUpdate_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyDataUpdate.SteamIDLobby">
            <summary>
            SteamID of the Lobby
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyDataUpdate.SteamIDMember">
            <summary>
            steamID of the member whose data changed, or the room itself
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyDataUpdate.Success">
            <summary>
            true if we lobby data was successfully changed; 
            will only be false if RequestLobbyData() was called on a lobby that no longer exists
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LobbyChatUpdate">
            <summary>
            The lobby chat room state has changed.
            This is usually sent when a user has joined or left the lobby
            
            Wrapper for the \a LobbyChatUpdate_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyChatUpdate.SteamIDLobby">
            <summary>
            Lobby ID
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyChatUpdate.SteamIDUserChanged">
            <summary>
            user who's status in the lobby just changed - can be recipient
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyChatUpdate.SteamIDMakingChange">
            <summary>
            Chat member who made the change (different from SteamIDUserChange if kicking, muting, etc.).
            For example, if one user kicks another from the lobby, this will be set to the id of the user who initiated the kick
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LobbyChatMsg">
            <summary>
            A chat message for this lobby has been sent.
            Use GetLobbyChatEntry( m_iChatID ) to retrieve the contents of this message
            
            Wrapper for the \a LobbyChatMsg_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyChatMsg.SteamIDLobby">
            <summary>
            the lobby id this is in
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyChatMsg.SteamIDUser">
            <summary>
            steamID of the user who has sent this message
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyChatMsg.ChatEntryType">
            <summary>
            type of message
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyChatMsg.ChatID">
            <summary>
            index of the chat entry to lookup
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LobbyGameCreated">
            <summary>
            A game created a game for all the members of the lobby to join,
            as triggered by a SetLobbyGameServer()
            it's up to the individual clients to take action on this; the usual
            game behavior is to leave the lobby and connect to the specified game server
            
            Wrapper for the \a LobbyGameCreated_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyGameCreated.SteamIDLobby">
            <summary>
            the lobby we were in
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyGameCreated.SteamIDGameServer">
            <summary>
            the new game server that has been created or found for the lobby members
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyGameCreated.IP">
            <summary>
            IP of the game server (if any)
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LobbyMatchList">
            <summary>
            Number of matching lobbies found.
            Iterate the returned lobbies with GetLobbyByIndex(), from values 0 to m_nLobbiesMatching-1
            
            Wrapper for the \a LobbyMatchList_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyMatchList.LobbiesMatching">
            <summary>
            Number of lobbies that matched search criteria and we have SteamIDs for
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LobbyKicked">
            <summary>
            posted if a user is forcefully removed from a lobby.
            can occur if a user loses connection to Steam
            
            Wrapper for the \a LobbyKicked_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyKicked.SteamIDLobby">
            <summary>
            Lobby
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyKicked.SteamIDAdmin">
            <summary>
            User who kicked you - possibly the ID of the lobby itself
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyKicked.KickedDueToDisconnect">
            <summary>
            true if you were kicked from the lobby due to the user losing connection 
            to Steam (currently always true)
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LobbyCreated">
            <summary>
            Result of our request to create a Lobby.
            m_eResult == k_EResultOK on success
            at this point, the lobby has been joined and is ready for use
            a LobbyEnter_t callback will also be received (since the local user is joining their own lobby)
            
            Wrapper for the \a LobbyCreated_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyCreated.Result">
            <summary>
            \li OK - the lobby was successfully created
            \li NoConnection - your Steam client doesn't have a connection to the back-end
            \li Timeout - you the message to the Steam servers, but it didn't respond
            \li Fail - the server responded, but with an unknown internal error
            \li AccessDenied - your game isn't set to allow lobbies, or your client does haven't rights to play the game
            \li LimitExceeded - your game client has created too many lobbies
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.LobbyCreated.SteamIDLobby">
            <summary>
            chat room, zero if failed
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.P2PSessionRequest">
            <summary>
            callback notification - a user wants to talk to us over the P2P channel via the SendP2PPacket() API
            in response, a call to AcceptP2PPacketsFromUser() needs to be made, if you want to talk with them
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.P2PSessionRequest.SteamIDRemote">
            <summary>
            user we were sending packets to
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.P2PSessionConnectFail">
            <summary>
            callback notification - packets can't get through to the specified user via the SendP2PPacket() API.
            all packets queued packets unsent at this point will be dropped.
            further attempts to send will retry making the connection (but will be dropped if we fail again)
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.P2PSessionConnectFail.SteamIDRemote">
            <summary>
            user we were sending packets to
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.SocketStatusCallback">
            <summary>
            callback notification - status of a socket has changed.
            used as part of the CreateListenSocket() / CreateP2PConnectionSocket() 
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.SocketStatusCallback.Socket">
            <summary>
            the socket used to send/receive data to the remote host
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.SocketStatusCallback.ListenSocket">
            <summary>
            this is the server socket that we were listening on; NULL if this was an outgoing connection
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.SocketStatusCallback.SteamIDRemote">
            <summary>
            remote steamID we have connected to, if it has one
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.SocketStatusCallback.NetSocketState">
            <summary>
            socket state
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudFileShareResult">
            <summary>
            Wrapper for the \a RemoteStorageFileShareResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudDownloadUGCResult">
            <summary>
            Wrapper for the \a RemoteStorageDownloadUGCResult_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.CallbackStructures.CloudDownloadUGCResult.FileName">
            <summary>
            The name of the shared file
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudPublishFileResult">
            <summary>
            Wrapper for the \a RemoteStoragePublishFileResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudUpdatePublishedFileResult">
            <summary>
            Wrapper for the \a RemoteStorageUpdatePublishedFileResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudGetPublishedFileDetailsResult">
            <summary>
            Wrapper for the \a RemoteStorageGetPublishedFileDetailsResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudDeletePublishedFileResult">
            <summary>
            Wrapper for the \a RemoteStorageDeletePublishedFileResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudEnumerateUserPublishedFilesResult">
            <summary>
            Wrapper for the \a RemoteStorageEnumerateUserPublishedFilesResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudSubscribePublishedFileResult">
            <summary>
            Wrapper for the \a RemoteStorageSubscribePublishedFileResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudEnumerateUserSubscribedFilesResult">
            <summary>
            Wrapper for the \a RemoteStorageEnumerateUserSubscribedFilesResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudUnsubscribePublishedFileResult">
            <summary>
            Wrapper for the \a RemoteStorageUnsubscribePublishedFileResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudGetPublishedItemVoteDetailsResult">
            <summary>
            Wrapper for the \a RemoteStorageGetPublishedItemVoteDetailsResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudUpdateUserPublishedItemVoteResult">
            <summary>
            Wrapper for the \a RemoteStorageUpdateUserPublishedItemVoteResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudUserVoteDetails">
            <summary>
            Wrapper for the \a RemoteStorageUserVoteDetails_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudEnumerateUserSharedWorkshopFilesResult">
            <summary>
            Wrapper for the \a RemoteStorageEnumerateUserSharedWorkshopFilesResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudSetUserPublishedFileActionResult">
            <summary>
            Wrapper for the \a RemoteStorageSetUserPublishedFileActionResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudEnumeratePublishedFilesByUserActionResult">
            <summary>
            Wrapper for the \a RemoteStorageEnumeratePublishedFilesByUserActionResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CloudEnumerateWorkshopFilesResult">
            <summary>
            Wrapper for the \a RemoteStorageEnumerateWorkshopFilesResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.UserStatsReceived">
            <summary>
            Wrapper for the \a UserStatsReceived_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.UserStatsStored">
            <summary>
            Wrapper for the \a UserStatsStored_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.UserStatsUnloaded">
            <summary>
            Wrapper for the \a UserStatsUnloaded_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GlobalStatsReceived">
            <summary>
            Wrapper for the \a GlobalStatsReceived_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.NumberOfCurrentPlayers">
            <summary>
            Wrapper for the \a NumberOfCurrentPlayers_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.UserAchievementStored">
            <summary>
            Wrapper for the \a UserAchievementStored_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.UserAchievementIconFetched">
            <summary>
            Wrapper for the \a UserAchievementIconFetched_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GlobalAchievementPercentagesReady">
            <summary>
            Wrapper for the \a GlobalAchievementPercentagesReady_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LeaderboardFindResult">
            <summary>
            Wrapper for the \a LeaderboardFindResult_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LeaderboardScoresDownloaded">
            <summary>
            Wrapper for the \a LeaderboardScoresDownloaded_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LeaderboardScoreUploaded">
            <summary>
            Wrapper for the \a LeaderboardScoreUploaded_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LeaderboardUGCSet">
            <summary>
            Wrapper for the \a LeaderboardUGCSet_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.SteamServersConnected">
            <summary>
            Wrapper for the \a SteamServersConnected_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.SteamServerConnectFailure">
            <summary>
            Wrapper for the \a SteamServerConnectFailure_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.SteamServersDisconnected">
            <summary>
            Wrapper for the \a SteamServersDisconnected_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.ClientGameServerDeny">
            <summary>
            Wrapper for the \a ClientGameServerDeny_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.IPCFailure">
            <summary>
            Wrapper for the \a IPCFailure_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.ValidateAuthTicketResponse">
            <summary>
            Wrapper for the \a ValidateAuthTicketResponse_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.MicroTxnAuthorizationResponse">
            <summary>
            Wrapper for the \a MicroTxnAuthorizationResponse_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.EncryptedAppTicketResponse">
            <summary>
            Wrapper for the \a EncryptedAppTicketResponse_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GetAuthSessionTicketResponse">
            <summary>
            Wrapper for the \a GetAuthSessionTicketResponse_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GameWebCallback">
            <summary>
            Wrapper for the \a GameWebCallback_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.IPCountry">
            <summary>
            called when a users coutry changes.
            
            Wrapper for the \steamref IPCountry_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.LowBatteryPower">
            <summary>
            called when running on a laptop and less then 10 minutes of battery if left,
            fires then every minute.
            
            Wrapper for the \steamref LowBatteryPower_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.SteamAPICallCompleted">
            <summary>
            called when SteamAsyncCall_t has completed (or failed).
            
            Wrapper for the \steamref SteamAPICallCompleted_t
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.SteamShutdown">
            <summary>
            Called when steam want to shut down.
            
            Wrapper for \steamref SteamShutdown_t
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.CheckFileSignature">
            <summary>
            Callback for CheckFileSignature.
            
            Wrapper for \steamref CheckFileSignature_t
            </summary>
        </member>
        <member name="T:ManagedSteam.CallbackStructures.GamepadTextInputDismissed">
            <summary>
            Called when Big Picture gamepad text input has been closed
            
            Wrapper for the \steamref GamepadTextInputDismissed_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.ICloud">
            <summary>
            Does all cloud communication.
            Wraps ISteamRemoteStorage.
            </summary>
        </member>
        <member name="M:ManagedSteam.ICloud.Write(System.String,System.IntPtr,System.Int32)">
             <summary>
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.bar" then
             iterate the files, the filename returned will be "foo.bar".
            
             </summary>
             <param name="fileName"></param>
             <param name="data"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.Read(System.String,System.IntPtr,System.Int32)">
             <summary>
             Will read data from the file and place it in the IntPtr. Will try to read \c dataToRead 
             number of bytes and place them in the array.
             
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.bar" then
             iterate the files, the filename returned will be "foo.bar".
             </summary>
             <param name="fileName"></param>
             <param name="data"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.Forget(System.String)">
             <summary>
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.bar" then
             iterate the files, the filename returned will be "foo.bar".
             </summary>
             <param name="fileName"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.Delete(System.String)">
             <summary>
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.b
             iterate the files, the filename returned will be "foo.bar".
             </summary>
             <param name="fileName"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.Share(System.String)">
             <summary>
             Invokes CloudFileShareResult
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.b
             iterate the files, the filename returned will be "foo.bar".
             </summary>
             <param name="fileName"></param>
        </member>
        <member name="M:ManagedSteam.ICloud.SetSyncPlatforms(System.String,ManagedSteam.SteamTypes.RemoteStoragePlatform)">
             <summary>
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.b
             iterate the files, the filename returned will be "foo.bar".
             </summary>
             <param name="fileName"></param>
             <param name="remoteStoragePlatform"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.Exists(System.String)">
             <summary>
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.b
             iterate the files, the filename returned will be "foo.bar".
             </summary>
             <param name="fileName"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.Persisted(System.String)">
             <summary>
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.b
             iterate the files, the filename returned will be "foo.bar".
             </summary>
             <param name="fileName"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.GetSize(System.String)">
             <summary>
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.b
             iterate the files, the filename returned will be "foo.bar".
             </summary>
             <param name="fileName"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.Timestamp(System.String)">
             <summary>
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.b
             iterate the files, the filename returned will be "foo.bar".
             </summary>
             <param name="fileName"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.GetSyncPlatforms(System.String)">
             <summary>
             NOTE
            
             Filenames are case-insensitive, and will be converted to lowercase automatically.
             So "foo.bar" and "Foo.bar" are the same file, and if you write "Foo.b
             iterate the files, the filename returned will be "foo.bar".
             </summary>
             <param name="fileName"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.UGCDownload(ManagedSteam.SteamTypes.UGCHandle,System.UInt32)">
            <summary>
            Invokes CloudDownloadUGCResult
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:ManagedSteam.ICloud.GetUGCDownloadProgress(ManagedSteam.SteamTypes.UGCHandle,System.Int32@,System.Int32@)">
            <summary>
            Gets the amount of data downloaded so far for a piece of content. pnBytesExpected can be 0 if function returns false
            or if the transfer hasn't started yet, so be careful to check for that before dividing to get a percentage
            </summary>
            <param name="handle"></param>
            <param name="bytesDownloaded"></param>
            <param name="bytesExpected"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.GetUGCDownloadProgress(ManagedSteam.SteamTypes.UGCHandle)">
            <summary>
            Gets the amount of data downloaded so far for a piece of content. pnBytesExpected can be 0 if function returns false
            or if the transfer hasn't started yet, so be careful to check for that before dividing to get a percentage
            </summary>
            <param name="handle"></param>
            <param name="bytesDownloaded"></param>
            <param name="bytesExpected"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.GetUGCDetails(ManagedSteam.SteamTypes.UGCHandle,ManagedSteam.SteamTypes.AppID@,System.String@,System.Int32@,ManagedSteam.SteamTypes.SteamID@)">
            <summary>
            Gets metadata for a file after it has been downloaded. This is the same metadata given in the RemoteStorageDownloadUGCResult_t call result
            </summary>
        </member>
        <member name="M:ManagedSteam.ICloud.GetUGCDetails(ManagedSteam.SteamTypes.UGCHandle)">
            <summary>
            Gets metadata for a file after it has been downloaded. This is the same metadata given in the RemoteStorageDownloadUGCResult_t call result
            </summary>
        </member>
        <member name="M:ManagedSteam.ICloud.UGCRead(ManagedSteam.SteamTypes.UGCHandle,System.Byte[],System.UInt32,ManagedSteam.SteamTypes.UGCReadAction)">
            <summary>
            After download, gets the content of the file
            </summary>
            <param name="handle"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.ICloud.GetCachedUGCCount">
            <summary>
            Functions to iterate through UGC that has finished downloading but has not yet been read via UGCRead(
            </summary>
            <returns></returns>
        </member>
        <member name="E:ManagedSteam.ICloud.CloudFileShareResult">
            <summary>
            Invoked by Share()
            </summary>
        </member>
        <member name="E:ManagedSteam.ICloud.CloudDownloadUGCResult">
            <summary>
            Invoked by UGCDownload()
            </summary>
        </member>
        <member name="T:ManagedSteam.Constants">
            <summary>
            This class contains all the constants that are defined in the Steamworks SDK
            </summary>
        </member>
        <member name="T:ManagedSteam.Constants.VersionInfo">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedSteam.Constants.Cloud">
            <summary>
            Constants from ISteamRemoteStorage.h
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Cloud.MaxFileSize">
            <summary>
            Defines the largest allowed file size. Cloud files cannot be
            larger than 100MB.
            </summary>
        </member>
        <member name="T:ManagedSteam.Constants.Stats">
            <summary>
            Constants from ISteamUserStats.h
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Stats.StatNameMax">
            <summary>
            size limit on stat or achievement name (UTF-8 encoded)
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Stats.LeaderboardNameMax">
            <summary>
            maximum number of bytes for a leaderboard name (UTF-8 encoded)
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Stats.LeaderboardDetailsMax">
            <summary>
            maximum number of details int32's storable for a single leaderboard entry
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Friends.MaxFriendsGroupName">
            <summary>
            maximum length of friend group name (not including terminating nul!)
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Friends.FriendsGroupLimit">
            <summary>
            maximum number of groups a single user is allowed
            </summary>
        </member>
        <member name="T:ManagedSteam.Constants.Matchmaking">
            <summary>
            Constants from the ISteamMatchmaking.h file
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.MaxLobbyValueLength">
            <summary>
            \note This value is not specified anywhere in the Steamworks SDK. It is based on a guess. 
            It might be wrong.
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.FavoriteFlagFavorite">
            <summary>
            this game favorite entry is for the favorites list
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.FavoriteFlagHistory">
            <summary>
            this game favorite entry is for the history list
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.KeyValuePairMaxKeySize">
            <summary>
            The max size of the string in bytes, not characters, including the null terminator.
            Use Utility.StringHelper.GetByteCount() to check the string size
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.KeyValuePairMaxValueSize">
            <summary>
            The max size of the string in bytes, not characters, including the null terminator.
            Use Utility.StringHelper.GetByteCount() to check the string size
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.MaxGameServerGameDir">
            <summary>
            Max size (in bytes of UTF-8 data, not in characters) of server fields, including null terminator.
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.MaxGameServerMapName">
            <summary>
            Max size (in bytes of UTF-8 data, not in characters) of server fields, including null terminator.
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.MaxGameServerGameDescription">
            <summary>
            Max size (in bytes of UTF-8 data, not in characters) of server fields, including null terminator.
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.MaxGameServerName">
            <summary>
            Max size (in bytes of UTF-8 data, not in characters) of server fields, including null terminator.
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.MaxGameServerTags">
            <summary>
            Max size (in bytes of UTF-8 data, not in characters) of server fields, including null terminator.
            </summary>
        </member>
        <member name="F:ManagedSteam.Constants.Matchmaking.MaxGameServerGameData">
            <summary>
            Max size (in bytes of UTF-8 data, not in characters) of server fields, including null terminator.
            </summary>
        </member>
        <member name="T:ManagedSteam.Exceptions.AlreadyLoadedException">
            <summary>
            Thrown if Steam::Initialize() is called twice.
            </summary>
        </member>
        <member name="T:ManagedSteam.Exceptions.NativeException">
            <summary>
            Base for all exceptions caused by errors in the native code.
            </summary>
        </member>
        <member name="T:ManagedSteam.Exceptions.CallbackStructSizeMismatchException">
            <summary>
            Thrown if the structure sizes mismatch between the native and managed code.
            This is never thrown as a result of usage error.
            </summary>
        </member>
        <member name="T:ManagedSteam.Exceptions.ManagedException">
            <summary>
            The base for all exceptions caused by errors in the managed code.
            </summary>
        </member>
        <member name="T:ManagedSteam.Exceptions.InvalidInterfaceVersionException">
            <summary>
            Thrown if the interface versions for the managed and native dlls mismatch.
            This can occur if updating from one version to another and forgetting to update either file.
            </summary>
        </member>
        <member name="T:ManagedSteam.Exceptions.SteamInitializeFailedException">
            <summary>
            Thrown if the call to SteamAPI_InitSafe() fails. Usually the result of a missing steam_appid.txt file
            or if the Steam client is not running.
            </summary>
        </member>
        <member name="T:ManagedSteam.Exceptions.SteamInterfaceInitializeFailedException">
            <summary>
            Thrown if the call to CSteamAPIContext::Init() fails.
            Happens if an old version of the Steamworks SDK is used.
            \see \ref version_info
            </summary>
        </member>
        <member name="T:ManagedSteam.Exceptions.UsageAfterAPIShutdownException">
            <summary>
            Thrown if any part of the library is used after \link Steam::Shutdown() Shutdown \endlink or
            \link Steam::ReleaseManagedResources() ReleaseManagedResources \endlink is called on the Steam class.
            </summary>
        </member>
        <member name="T:ManagedSteam.IFriends">
            <summary>
            Handles communication with the friends system and the game overlay.
            </summary>
        </member>
        <member name="M:ManagedSteam.IFriends.GetPersonaName">
            <summary>
            returns the local players name - guaranteed to not be NULL.
            this is the same name as on the users community profile page
            this is stored in UTF-8 format
            like all the other interface functions that return a char *, it's important that this pointer is not saved
            off; it will eventually be free'd or re-allocated
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.SetPersonaName(System.String)">
            <summary>
            sets the player name, stores it on the server and publishes the changes to all friends who are online
            </summary>
            <param name="personaName"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.GetPersonaState">
            <summary>
            gets the status of the current user
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendCount(ManagedSteam.SteamTypes.FriendFlags)">
            <summary>
            friend iteration
            takes a set of k_EFriendFlags, and returns the number of users the client knows about who meet that criteria
            then GetFriendByIndex() can then be used to return the id's of each of those users
            </summary>
            <param name="friendFlags"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendByIndex(System.Int32,ManagedSteam.SteamTypes.FriendFlags)">
            <summary>
            returns the steamID of a user
            iFriend is a index of range [0, GetFriendCount())
            iFriendsFlags must be the same value as used in GetFriendCount()
            the returned CSteamID can then be used by all the functions below to access details about the user
            </summary>
            <param name="friendIndex"></param>
            <param name="friendFlags"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendRelationship(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns a relationship to a user
            </summary>
            <param name="steamIDFriend"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendPersonaState(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the current status of the specified user
            this will only be known by the local user if steamIDFriend is in their friends list; on the same game server; in a chat room or lobby; or in a small group with the local user
            </summary>
            <param name="steamIDFriend"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendPersonaName(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the name another user - guaranteed to not be NULL.
            same rules as GetFriendPersonaState() apply as to whether or not the user knowns the name of the other user
            note that on first joining a lobby, chat room or game server the local user will not known the name of the other users automatically; that information will arrive asyncronously
            </summary>
            <param name="steamIDFriend"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendGamePlayed(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.FriendGameInfo@)">
            <summary>
            returns true if the friend is actually in a game, and fills in pFriendGameInfo with an extra details
            </summary>
            <param name="steamIDFriend"></param>
            <param name="friendGameInfo"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendGamePlayed(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns true if the friend is actually in a game, and fills in pFriendGameInfo with an extra details
            </summary>
            <param name="steamIDFriend"></param>
            <param name="friendGameInfo"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendPersonaNameHistory(ManagedSteam.SteamTypes.SteamID,System.Int32)">
            <summary>
            accesses old friends names - returns an empty string when their are no more items in the histor
            </summary>
            <param name="steamIDFriend"></param>
            <param name="personaName"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetPlayerNickname(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Returns nickname the current user has set for the specified player. Returns NULL if the no nickname has been set for that player.
            </summary>
            <param name="steamIDPlayer"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.HasFriend(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.FriendFlags)">
            <summary>
            returns true if the specified user meets any of the criteria specified in iFriendFlags
            iFriendFlags can be the union (binary or, |) of one or more k_EFriendFlags values
            </summary>
            <param name="steamIDFriend"></param>
            <param name="friendFlags"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanCount">
            <summary>
            clan (group) iteration and access function
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanByIndex(System.Int32)">
            <summary>
            clan (group) iteration and access function
            </summary>
            <param name="clan"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanName(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            clan (group) iteration and access function
            </summary>
            <param name="steamIDClan"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanTag(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            clan (group) iteration and access function
            </summary>
            <param name="steamIDClan"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanActivityCounts(ManagedSteam.SteamTypes.SteamID,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            returns the most recent information we have about what's happening in a clan
            </summary>
            <param name="steamIDClan"></param>
            <param name="online"></param>
            <param name="inGame"></param>
            <param name="chatting"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanActivityCounts(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the most recent information we have about what's happening in a clan
            </summary>
            <param name="steamIDClan"></param>
            <param name="online"></param>
            <param name="inGame"></param>
            <param name="chatting"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.DownloadClanActivityCounts(ManagedSteam.SteamTypes.SteamID[])">
            <summary>
            for clans a user is a member of, they will have reasonably up-to-date information, but for others you'll have to download the info to have the latest
            </summary>
            <param name="clanIDs"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendCountFromSource(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            iterator for getting users in a chat room, lobby, game server or clan
            note that large clans that cannot be iterated by the local user
            note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby
            steamIDSource can be the steamID of a group, game server, lobby or chat room
            </summary>
            <param name="steamIDSource"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendFromSourceByIndex(ManagedSteam.SteamTypes.SteamID,System.Int32)">
            <summary>
            iterator for getting users in a chat room, lobby, game server or clan
            note that large clans that cannot be iterated by the local user
            note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby
            steamIDSource can be the steamID of a group, game server, lobby or chat room
            </summary>
            <param name="steamIDSource"></param>
            <param name="friendIndex"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.IsUserInSource(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns true if the local user can see that steamIDUser is a member or in steamIDSource
            </summary>
            <param name="steamIDUser"></param>
            <param name="steamIDSource"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.SetInGameVoiceSpeaking(ManagedSteam.SteamTypes.SteamID,System.Boolean)">
            <summary>
            User is in a game pressing the talk button (will suppress the microphone for all voice comms from the Steam friends UI)
            </summary>
            <param name="steamIDUser"></param>
            <param name="speaking"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.ActivateGameOverlay(ManagedSteam.OverlayDialog)">
            <summary>
            activates the game overlay, with an optional dialog to open 
            valid options are "Friends", "Community", "Players", "Settings", "OfficialGameGroup", "Stats", "Achievements"
            </summary>
            <param name="dialogType"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.ActivateGameOverlayToUser(ManagedSteam.OverlayDialogToUser,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            activates game overlay to a specific place
            valid options are
            	"steamid" - opens the overlay web browser to the specified user or groups profile
            	"chat" - opens a chat window to the specified user, or joins the group chat 
            	"jointrade" - opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API
            	"stats" - opens the overlay web browser to the specified user's stats
            	"achievements" - opens the overlay web browser to the specified user's achievement
            </summary>
            <param name="dialogType"></param>
            <param name="steamID"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.ActivateGameOverlayToWebPage(System.String)">
            <summary>
            activates game overlay web browser directly to the specified URL
            full address with protocol type is required, e.g. http://www.steamgames.com/
            </summary>
            <param name="url"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.ActivateGameOverlayToStore(ManagedSteam.SteamTypes.AppID,ManagedSteam.SteamTypes.OverlayToStoreFlag)">
            <summary>
            activates game overlay to store page for app
            </summary>
            <param name="appID"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.SetPlayedWith(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Mark a target user as 'played with'. This is a client-side only feature that requires that the calling user is 
            in game 
            </summary>
            <param name="steamIDUserPlayedWith"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.ActivateGameOverlayInviteDialog(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            activates game overlay to open the invite dialog. Invitations will be sent for the provided lobby.
            </summary>
            <param name="steamIDLobby"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.GetSmallFriendAvatar(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            gets the small (32x32) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set
            </summary>
            <param name="steamIDFriend"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetMediumFriendAvatar(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            gets the medium (64x64) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set
            </summary>
            <param name="steamIDFriend"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetLargeFriendAvatar(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            gets the large (184x184) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set
            returns -1 if this image has yet to be loaded, in this case wait for a AvatarImageLoaded_t callback and then call this again
            </summary>
            <param name="steamIDFriend"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.RequestUserInformation(ManagedSteam.SteamTypes.SteamID,System.Boolean)">
            <summary>
            requests information about a user - persona name and avatar
            if bRequireNameOnly is set, then the avatar of a user isn't downloaded 
            - it's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them
            if returns true, it means that data is being requested, and a PersonaStateChanged_t callback will be posted when it's retrieved
            if returns false, it means that we already have all the details about that user, and functions can be called immediatel
            </summary>
            <param name="steamIDUser"></param>
            <param name="requireNameOnly"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.RequestClanOfficerList(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            requests information about a clan officer list
            when complete, data is returned in ClanOfficerListResponse_t call result
            this makes available the calls below
            you can only ask about clans that a user is a member of
            note that this won't download avatars automatically; if you get an officer,
            and no avatar image is available, call RequestUserInformation( steamID, false ) to download the avatar
            </summary>
            <param name="steamIDClan"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanOwner(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the steamID of the clan owner
            </summary>
            <param name="steamIDClan"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanOfficerCount(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the number of officers in a clan (including the owner)
            </summary>
            <param name="steamIDClan"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanOfficerByIndex(ManagedSteam.SteamTypes.SteamID,System.Int32)">
            <summary>
            returns the steamID of a clan officer, by index, of range [0,GetClanOfficerCount)
            </summary>
            <param name="steamIDClan"></param>
            <param name="officer"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetUserRestrictions">
            <summary>
            if current user is chat restricted, he can't send or receive any text/voice chat messages.
            the user can't see custom avatars. But the user can be online and send/recv game invites.
            a chat restricted user can't add friends or join any groups.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.SetRichPresence(System.String,System.String)">
            <summary>
            if current user is chat restricted, he can't send or receive any text/voice chat messages.
            the user can't see custom avatars. But the user can be online and send/recv game invites.
            a chat restricted user can't add friends or join any group
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.ClearRichPresence">
            <summary>
            Rich Presence data is automatically shared between friends who are in the same game
            Each user has a set of Key/Value pairs
            Up to 20 different keys can be set
            There are two magic keys:
            	"status"  - a UTF-8 string that will show up in the 'view game info' dialog in the Steam friends list
            	"connect" - a UTF-8 string that contains the command-line for how a friend can connect to a game
            SetRichPresence() to a NULL or an empty string deletes the key
            You can iterate the current set of keys for a friend with GetFriendRichPresenceKeyCount()
            and GetFriendRichPresenceKeyByIndex() (typically only used for debugging)
            </summary>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendRichPresence(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
             returns an empty string "" if no value is set
            </summary>
            <param name="steamIDFriend"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendRichPresenceKeyCount(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Rich Presence data is automatically shared between friends who are in the same game
            Each user has a set of Key/Value pairs
            Up to 20 different keys can be set
            There are two magic keys:
            	"status"  - a UTF-8 string that will show up in the 'view game info' dialog in the Steam friends list
            	"connect" - a UTF-8 string that contains the command-line for how a friend can connect to a game
            SetRichPresence() to a NULL or an empty string deletes the key
            You can iterate the current set of keys for a friend with GetFriendRichPresenceKeyCount()
            and GetFriendRichPresenceKeyByIndex() (typically only used for debugging)
            </summary>
            <param name="steamIDFriend"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendRichPresenceKeyByIndex(ManagedSteam.SteamTypes.SteamID,System.Int32)">
            <summary>
            Rich Presence data is automatically shared between friends who are in the same game
            Each user has a set of Key/Value pairs
            Up to 20 different keys can be set
            There are two magic keys:
            	"status"  - a UTF-8 string that will show up in the 'view game info' dialog in the Steam friends list
            	"connect" - a UTF-8 string that contains the command-line for how a friend can connect to a game
            SetRichPresence() to a NULL or an empty string deletes the key
            You can iterate the current set of keys for a friend with GetFriendRichPresenceKeyCount()
            and GetFriendRichPresenceKeyByIndex() (typically only used for debugging)
            </summary>
            <param name="steamIDFriend"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.RequestFriendRichPresence(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Requests rich presence for a specific user.
            </summary>
            <param name="steamIDFriend"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.InviteUserToGame(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            rich invite support
            if the target accepts the invite, the pchConnectString gets added to the command-line for launching the game
            if the game is already running, a GameRichPresenceJoinRequested_t callback is posted containing the connect string
            invites can only be sent to friends
            </summary>
            <param name="steamIDFriend"></param>
            <param name="connectString"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetCoplayFriendCount">
            <summary>
            recently-played-with friends iteration
            this iterates the entire list of users recently played with, across games
            GetFriendCoplayTime() returns as a unix time 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetCoplayFriend(System.Int32)">
            <summary>
            recently-played-with friends iteration
            this iterates the entire list of users recently played with, across games
            GetFriendCoplayTime() returns as a unix time 
            </summary>
            <param name="coplayFriend"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendCoplayTime(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            recently-played-with friends iteration
            this iterates the entire list of users recently played with, across games
            GetFriendCoplayTime() returns as a unix time 
            </summary>
            <param name="steamIDFriend"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendCoplayGame(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            recently-played-with friends iteration
            this iterates the entire list of users recently played with, across games
            GetFriendCoplayTime() returns as a unix time 
            </summary>
            <param name="steamIDFriend"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.JoinClanChatRoom(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            chat interface for games
            this allows in-game access to group (clan) chats from in the game
            the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay
            use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat
            </summary>
            <param name="steamIDClan"></param>
        </member>
        <member name="M:ManagedSteam.IFriends.LeaveClanChatRoom(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            chat interface for games
            this allows in-game access to group (clan) chats from in the game
            the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay
            use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat 
            </summary>
            <param name="steamIDClan"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanChatMemberCount(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            chat interface for games
            this allows in-game access to group (clan) chats from in the game
            the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay
            use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat 
            </summary>
            <param name="steamIDClan"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetChatMemberByIndex(ManagedSteam.SteamTypes.SteamID,System.Int32)">
            <summary>
            chat interface for games
            this allows in-game access to group (clan) chats from in the game
            the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay
            use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat
            </summary>
            <param name="steamIDClan"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.SendClanChatMessage(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            chat interface for games
            this allows in-game access to group (clan) chats from in the game
            the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay
            use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat
            </summary>
            <param name="steamIDClanChat"></param>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanChatMessage(ManagedSteam.SteamTypes.SteamID,System.Int32,System.Int32,System.String@,ManagedSteam.SteamTypes.ChatEntryType@,ManagedSteam.SteamTypes.SteamID@)">
            <summary>
            chat interface for games
            this allows in-game access to group (clan) chats from in the game
            the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay
            use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat
            </summary>
            <param name="steamIDClanChat"></param>
            <param name="message"></param>
            <param name="maxMessageSize"></param>
            <param name="text"></param>
            <param name="chatEntryType"></param>
            <param name="sender"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetClanChatMessage(ManagedSteam.SteamTypes.SteamID,System.Int32,System.Int32)">
            <summary>
            chat interface for games
            this allows in-game access to group (clan) chats from in the game
            the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay
            use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat
            </summary>
            <param name="steamIDClanChat"></param>
            <param name="message"></param>
            <param name="text"></param>
            <param name="textSize"></param>
            <param name="chatEntryType"></param>
            <param name="sender"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.IsClanChatAdmin(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            chat interface for games
            this allows in-game access to group (clan) chats from in the game
            the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay
            use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat
            </summary>
            <param name="steamIDClanChat"></param>
            <param name="steamIDUser"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.IsClanChatWindowOpenInSteam(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            interact with the Steam (game overlay / desktop)
            </summary>
            <param name="steamIDClanChat"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.OpenClanChatWindowInSteam(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            interact with the Steam (game overlay / desktop)
            </summary>
            <param name="steamIDClanChat"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.CloseClanChatWindowInSteam(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            interact with the Steam (game overlay / desktop)
            </summary>
            <param name="steamIDClanChat"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.SetListenForFriendsMessages(System.Boolean)">
            <summary>
            peer-to-peer chat interception
            this is so you can show P2P chats inline in the game
            </summary>
            <param name="interceptEnabled"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.ReplyToFriendMessage(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            peer-to-peer chat interception
            this is so you can show P2P chats inline in the game
            </summary>
            <param name="steamIDFriend"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendMessage(ManagedSteam.SteamTypes.SteamID,System.Int32,System.Int32,System.String@,ManagedSteam.SteamTypes.ChatEntryType@)">
            <summary>
            peer-to-peer chat interception
            this is so you can show P2P chats inline in the game
            </summary>
            <param name="steamIDFriend"></param>
            <param name="messageID"></param>
            <param name="text"></param>
            <param name="chatEntryType"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFriendMessage(ManagedSteam.SteamTypes.SteamID,System.Int32,System.Int32)">
            <summary>
            peer-to-peer chat interception
            this is so you can show P2P chats inline in the game
            </summary>
            <param name="steamIDFriend"></param>
            <param name="messageID"></param>
            <param name="text"></param>
            <param name="chatEntryType"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IFriends.GetFollowerCount(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            following apis
            </summary>
            <param name="steamID"></param>
        </member>
        <member name="T:ManagedSteam.IGameServer">
            <summary>
            Purpose: interface to steam for game servers
            </summary>
        </member>
        <member name="M:ManagedSteam.IGameServer.InitGameServer(System.UInt32,System.UInt16,System.UInt16,System.UInt32,ManagedSteam.SteamTypes.AppID,System.String)">
            <summary>
            This is called by SteamGameServer_Init, and you will usually not need to call it directly
            </summary>
            <param name="ip"></param>
            <param name="gamePort"></param>
            <param name="queryPort"></param>
            <param name="flags"></param>
            <param name="gameAppId"></param>
            <param name="versionString"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetProduct(System.String)">
            <summary>
            Game product identifier.  This is currently used by the master server for version checking purposes.
            It's a required field, but will eventually will go away, and the AppID will be used for this purpose.
            </summary>
            <param name="product"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetGameDescription(System.String)">
            <summary>
            Description of the game.  This is a required field and is displayed in the steam server browser....for now.
            This is a required field, but it will go away eventually, as the data should be determined from the AppID.
            </summary>
            <param name="gameDescription"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetModDir(System.String)">
            <summary>
            If your game is a "mod," pass the string that identifies it.  The default is an empty string, meaning
            this application is the original game, not a mod.
            @see k_cbMaxGameServerGameDir
            </summary>
            <param name="modDir"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetDedicatedServer(System.Boolean)">
            Is this is a dedicated server?  The default value is false.
        </member>
        <member name="M:ManagedSteam.IGameServer.LogOn(System.String,System.String)">
            <summary>
            Begin process to login to a persistent game server account
            </summary>
            <param name="accountName"></param>
            <param name="password"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.LogOnAnonymous">
             <summary>
             Login to a generic, anonymous account.
            
             Note: in previous versions of the SDK, this was automatically called within SteamGameServer_Init,
             but this is no longer the case.
             </summary>
        </member>
        <member name="M:ManagedSteam.IGameServer.LogOff">
            <summary>
            Begin process of logging game server out of steam
            </summary>
        </member>
        <member name="M:ManagedSteam.IGameServer.LoggedOn">
            <summary>
            Status function
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.Secure">
            <summary>
            Status function
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.GetSteamID">
            <summary>
            Status function
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.WasRestartRequested">
            <summary>
            Returns true if the master server has requested a restart.
            Only returns true once per request.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetMaxPlayerCount(System.Int32)">
            <summary>
            Max player count that will be reported to server browser and client queries
            </summary>
            <param name="playersMax"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetBotPlayerCount(System.Int32)">
            <summary>
            Number of bots.  Default value is zero
            </summary>
            <param name="botplayers"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetServerName(System.String)">
            <summary>
            Set the name of server as it will appear in the server browser
            </summary>
            <param name="serverName"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetMapName(System.String)">
            <summary>
            Set name of map to report in the server browser
            </summary>
            <param name="mapName"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetPasswordProtected(System.Boolean)">
            <summary>
            Let people know if your server will require a password
            </summary>
            <param name="passwordProtected"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetSpectatorPort(System.UInt16)">
            <summary>
            Spectator server.  The default value is zero, meaning the service
            is not used.
            </summary>
            <param name="spectatorPort"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetSpectatorServerName(System.String)">
            <summary>
            Name of the spectator server.  (Only used if spectator port is nonzero.)
            </summary>
            <param name="spectatorServerName"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.ClearAllKeyValues">
            <summary>
            Call this to clear the whole list of key/values that are sent in rules queries.
            </summary>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetKeyValue(System.String,System.String)">
            <summary>
            Call this to add/update a key/value pair.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetGameTags(System.String)">
            <summary>
            Sets a string defining the "gametags" for this server, this is optional, but if it is set
            it allows users to filter in the matchmaking/server-browser interfaces based on the value
            
            \see Constants.Matchmaking.MaxGameServerTags
            </summary>
            <param name="gameTags"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetGameData(System.String)">
            <summary>
            Sets a string defining the "gamedata" for this server, this is optional, but if it is set
            it allows users to filter in the matchmaking/server-browser interfaces based on the value
            don't set this unless it actually changes, its only uploaded to the master once (when
            acknowledged)
            </summary>
            <param name="gameData"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetRegion(System.String)">
            <summary>
            Region identifier.  This is an optional field, the default value is empty, meaning the "world" region
            </summary>
            <param name="region"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SendUserConnectAndAuthenticate(System.UInt32,System.Byte[],ManagedSteam.SteamTypes.SteamID@)">
             <summary>
             Handles receiving a new connection from a Steam user.  This call will ask the Steam
             servers to validate the users identity, app ownership, and VAC status.  If the Steam servers 
             are off-line, then it will validate the cached ticket itself which will validate app ownership 
             and identity.  The AuthBlob here should be acquired on the game client using SteamUser()->InitiateGameConnection()
             and must then be sent up to the game server for authentication.
            
             Return Value: returns true if the users ticket passes basic checks. pSteamIDUser will contain the Steam ID of this user. pSteamIDUser must NOT be NULL
             If the call succeeds then you should expect a GSClientApprove_t or GSClientDeny_t callback which will tell you whether authentication
             for the user has succeeded or failed (the steamid in the callback will match the one returned by this call)
             </summary>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.CreateUnauthenticatedUserConnection">
             <summary>
            Creates a fake user (ie, a bot) which will be listed as playing on the server, but skips validation.  
             
             Return Value: Returns a SteamID for the user to be tracked with, you should call HandleUserDisconnect()
             when this user leaves the server just like you would for a real user.
             </summary>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.SendUserDisconnect(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Should be called whenever a user leaves our game server, this lets Steam internally
            track which users are currently on which servers for the purposes of preventing a single
            account being logged into multiple servers, showing who is currently on a server, etc.
            </summary>
            <param name="steamIDUser"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.UpdateUserData(ManagedSteam.SteamTypes.SteamID,System.String,System.UInt32)">
            <summary>
            Update the data to be displayed in the server browser and matchmaking interfaces for a user
            currently connected to the server.  For regular users you must call this after you receive a
            GSUserValidationSuccess callback.
            
            Return Value: true if successful, false if failure (ie, steamIDUser wasn't for an active player)
            </summary>
            <param name="steamIDUser"></param>
            <param name="playerName"></param>
            <param name="score"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.GetAuthSessionTicket(System.IntPtr,System.Int32,System.UInt32@)">
            <summary>
            New auth system APIs - do not mix with the old auth system APIs.
            ----------------------------------------------------------------
            Retrieve ticket to be sent to the entity who wishes to authenticate you ( using BeginAuthSession API ). 
            pcbTicket retrieves the length of the actual ticket.
            </summary>
            <param name="data"></param>
            <param name="ticket"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.BeginAuthSession(System.IntPtr,System.Int32,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Authenticate ticket ( from GetAuthSessionTicket ) from entity steamID to be sure it is valid and isnt reused
            Registers for callbacks if the entity goes offline or cancels the ticket ( see ValidateAuthTicketResponse_t callback and EAuthSessionResponse )
            </summary>
            <param name="authTicket"></param>
            <param name="steamID"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.EndAuthSession(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Stop tracking started by BeginAuthSession - called when no longer playing game with this entity
            </summary>
            <param name="steamID"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.CancelAuthTicket(ManagedSteam.SteamTypes.AuthTicketHandle)">
            <summary>
            Cancel auth ticket from GetAuthSessionTicket, called when no longer playing game with the entity you gave the ticket to
            </summary>
            <param name="authTicket"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.UserHasLicenseForApp(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.AppID)">
            <summary>
            After receiving a user's authentication data, and passing it to SendUserConnectAndAuthenticate, use this function
            to determine if the user owns downloadable content specified by the provided AppID.
            </summary>
            <param name="steamID"></param>
            <param name="appID"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.RequestUserGroupStatus(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Ask if a user in in the specified group, results returns async by GSUserGroupStatus_t
            returns false if we're not connected to the steam servers and thus cannot ask
            </summary>
            <param name="steamIDUser"></param>
            <param name="steamIDGroup"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.GetGameplayStats">
            <summary>
            Ask for the gameplay stats for the server. Results returned in a callback
            </summary>
        </member>
        <member name="M:ManagedSteam.IGameServer.GetServerReputation">
            <summary>
            Gets the reputation score for the game server. This API also checks if the server or some
            other server on the same IP is banned from the Steam master servers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.GetPublicIP">
            <summary>
            Returns the public IP of the server according to Steam, useful when the server is 
            behind NAT and you want to advertise its IP in a lobby for other clients to directly
            connect to
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.HandleIncomingPacket(System.Byte[],System.UInt32,System.UInt16)">
             <summary>
             These are in GameSocketShare mode, where instead of ISteamGameServer creating its own
             socket to talk to the master server on, it lets the game use its socket to forward messages
             back and forth. This prevents us from requiring server ops to open up yet another port
             in their firewalls.
            
             the IP address and port should be in host order, i.e 127.0.0.1 == 0x7f000001
            
             These are used when you've elected to multiplex the game server's UDP socket
             rather than having the master server updater use its own sockets.
             
             Source games use this to simplify the job of the server admins, so they 
             don't have to open up more ports on their firewalls.
            
             Call this when a packet that starts with 0xFFFFFFFF comes in. That means
             it's for us.
             </summary>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.GetNextOutgoingPacket(System.Byte[],System.UInt32@,System.UInt16@)">
            <summary>
            AFTER calling HandleIncomingPacket for any packets that came in that frame, call this.
            This gets a packet that the master server updater needs to send out on UDP.
            It returns the length of the packet it wants to send, or 0 if there are no more packets to send.
            Call this each frame until it returns 0
            </summary>
            <param name="data"></param>
            <param name="netAdr"></param>
            <param name="port"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.EnableHeartbeats(System.Boolean)">
            <summary>
            Call this as often as you like to tell the master server updater whether or not
            you want it to be active (default: off).
            </summary>
            <param name="active"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.SetHeartbeatInterval(System.Int32)">
             <summary>
            You usually don't need to modify this.
             Pass -1 to use the default value for iHeartbeatInterval.
             Some mods change this
             </summary>
             <param name="heartbeatInterval"></param>
        </member>
        <member name="M:ManagedSteam.IGameServer.ForceHeartbeat">
            <summary>
            Force a heartbeat to steam at the next opportunity
            </summary>
        </member>
        <member name="M:ManagedSteam.IGameServer.AssociateWithClan(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            associate this game server with this clan for the purposes of computing player compat
            </summary>
            <param name="steamIDClan"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServer.ComputeNewPlayerCompatibility(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            ask if any of the current players dont want to play with this new player - or vice versa
            </summary>
            <param name="steamIDNewPlayer"></param>
            <returns></returns>
        </member>
        <member name="T:ManagedSteam.IGameServerStats">
            <summary>
            Purpose: interface to steam for game servers
            </summary>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.RequestUserStats(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            downloads stats for the user
            returns a GSStatsReceived_t callback when completed
            if the user has no stats, GSStatsReceived_t.m_eResult will be set to k_EResultFail
            these stats will only be auto-updated for clients playing on the server. For other
            users you'll need to call RequestUserStats() again to refresh any data
            </summary>
            <param name="steamIDUser"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.GetUserStat(ManagedSteam.SteamTypes.SteamID,System.String,System.Int32@)">
            <summary>
            requests stat information for a user, usable after a successful call to RequestUserStats()
            </summary>
            <param name="steamIDUser"></param>
            <param name="name"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.GetUserStatInt(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            requests stat information for a user, usable after a successful call to RequestUserStats()
            </summary>
            <param name="steamIDUser"></param>
            <param name="name"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.GetUserStat(ManagedSteam.SteamTypes.SteamID,System.String,System.Single@)">
            <summary>
            requests stat information for a user, usable after a successful call to RequestUserStats()
            </summary>
            <param name="steamIDUser"></param>
            <param name="name"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.GetUserStatFloat(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            requests stat information for a user, usable after a successful call to RequestUserStats()
            </summary>
            <param name="steamIDUser"></param>
            <param name="name"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.GetUserAchievement(ManagedSteam.SteamTypes.SteamID,System.String,System.Boolean@)">
            <summary>
            requests achievement information for a user, usable after a successful call to RequestUserStats()
            </summary>
            <param name="steamIDUser"></param>
            <param name="name"></param>
            <param name="achieved"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.SetUserStat(ManagedSteam.SteamTypes.SteamID,System.String,System.Int32)">
            <summary>
            Set stats
            Note: This update will work only on stats game servers are allowed to edit and only for 
            game servers that have been declared as officially controlled by the game creators. 
            Set the IP range of your official servers on the Steamworks page
            </summary>
            <param name="steamIDUser"></param>
            <param name="name"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.SetUserStat(ManagedSteam.SteamTypes.SteamID,System.String,System.Single)">
            <summary>
            Set stats 
            Note: This update will work only on stats game servers are allowed to edit and only for 
            game servers that have been declared as officially controlled by the game creators. 
            Set the IP range of your official servers on the Steamworks page
            </summary>
            <param name="steamIDUser"></param>
            <param name="name"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.UpdateUserAvgRateStat(ManagedSteam.SteamTypes.SteamID,System.String,System.Single,System.Double)">
            <summary>
            Update stats. 
            Note: This update will work only on stats game servers are allowed to edit and only for 
            game servers that have been declared as officially controlled by the game creators. 
            Set the IP range of your official servers on the Steamworks page
            </summary>
            <param name="steamIDUser"></param>
            <param name="name"></param>
            <param name="countThisSession"></param>
            <param name="sessionLength"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.SetUserAchievement(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            Set achievements. 
            Note: This updates will work only on achievements game servers are allowed to edit and only for 
            game servers that have been declared as officially controlled by the game creators. 
            Set the IP range of your official servers on the Steamworks page
            </summary>
            <param name="steamIDUser"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.ClearUserAchievement(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            Clear achievements. 
            Note: This will work only on achievements game servers are allowed to edit and only for 
            game servers that have been declared as officially controlled by the game creators. 
            Set the IP range of your official servers on the Steamworks page
            </summary>
            <param name="steamIDUser"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IGameServerStats.StoreUserStats(ManagedSteam.SteamTypes.SteamID)">
             <summary>
             Store the current data on the server, will get a GSStatsStored_t callback when set.
            
             If the callback has a result of k_EResultInvalidParam, one or more stats 
             uploaded has been rejected, either because they broke constraints
             or were out of date. In this case the server sends back updated values.
             The stats should be re-iterated to keep in sync.
             </summary>
             <param name="steamIDUser"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHmd.GetWindowBounds(System.Int32@,System.Int32@,System.UInt32@,System.UInt32@)">
            <summary>
            Size and position that the window needs to be on the VR display.
            </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="Width"></param>
            <param name="Height"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHmd.GetRecommendedRenderTargetSize(System.UInt32@,System.UInt32@)">
            <summary>
            Suggested size for the intermediate render target that the distortion pulls from.
            </summary>
            <param name="Width"></param>
            <param name="Height"></param>
        </member>
        <member name="M:ManagedSteam.IHmd.GetEyeOutputViewport(ManagedSteam.SteamTypes.HmdEye,ManagedSteam.SteamTypes.GraphicsAPIConvention,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Gets the viewport in the frame buffer to draw the output of the disortion into.
            </summary>
            <param name="Eye"></param>
            <param name="APIType"></param>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="Width"></param>
            <param name="Height"></param>
        </member>
        <member name="M:ManagedSteam.IHmd.GetProjectionMatrix(ManagedSteam.SteamTypes.HmdEye,System.Single,System.Single,ManagedSteam.SteamTypes.GraphicsAPIConvention)">
            <summary>
            The projection matrix for the specified eye.
            </summary>
            <param name="Eye"></param>
            <param name="NearZ"></param>
            <param name="FarZ"></param>
            <param name="ProjType"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHmd.GetProjectionRaw(ManagedSteam.SteamTypes.HmdEye,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            The components necessary to build your own projection matrix in case your application is doing something fancy like infinite Z.
            </summary>
            <param name="Eye"></param>
            <param name="Left"></param>
            <param name="Right"></param>
            <param name="Top"></param>
            <param name="Bottom"></param>
        </member>
        <member name="M:ManagedSteam.IHmd.ComputeDistortion(ManagedSteam.SteamTypes.HmdEye,System.Single,System.Single)">
            <summary>
            Returns the result of the distortion function for the specified eye and input UVs. UVs go from 0,0 in the upper left of that eye's viewport and 1,1 in the lower right of that eye's viewport.
            </summary>
            <param name="Eye"></param>
            <param name="U"></param>
            <param name="V"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHmd.GetEyeMatrix(ManagedSteam.SteamTypes.HmdEye)">
            <summary>
            Returns the transform between the view space and eye space. Eye space is the per-eye flavor of view
            space that provides stereo disparity. Instead of Model * View * Projection the model is Model * View * Eye * Projection. 
            Normally View and Eye will be multiplied together and treated as View in your application. 
            </summary>
            <param name="Eye"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHmd.GetViewMatrix(System.Single,ManagedSteam.SteamTypes.HmdMatrix44@,ManagedSteam.SteamTypes.HmdMatrix44@,ManagedSteam.SteamTypes.HmdTrackingResult@)">
            <summary>
            For use in simple VR apps, this method returns the concatenation of the 
            tracking pose and the eye matrix to get a full view matrix for each eye.
            This is ( GetEyeMatrix() ) * (GetWorldFromHeadPose() ^ -1 )
            </summary>
            <param name="SecondsFromNow"></param>
            <param name="MatLeftView"></param>
            <param name="MatRightView"></param>
            <param name="peResult"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHmd.GetWorldFromHeadPose(System.Single,ManagedSteam.SteamTypes.HmdMatrix34@,ManagedSteam.SteamTypes.HmdTrackingResult@)">
            <summary>
            The pose that the tracker thinks that the HMD will be in at the specified
            number of seconds into the future. Pass 0 to get the current state. 
            
            This is roughly analagous to the inverse of the view matrix in most applications, though 
            many games will need to do some additional rotation or translation on top of the rotation
            and translation provided by the head pose.
            
            If this function returns true the pose has been populated with a pose that can be used by the application.
            Check peResult for details about the pose, including messages that should be displayed to the user.
            </summary>
            <param name="PredictedSecondsFromNow"></param>
            <param name="Pose"></param>
            <param name="Result"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHmd.GetLastWorldFromHeadPose(ManagedSteam.SteamTypes.HmdMatrix34@)">
            <summary>
            Passes back the pose matrix from the last successful call to GetWorldFromHeadPose(). Returns true if that matrix is 
            valid (because there has been a previous successful pose.)
            </summary>
            <param name="Pose"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHmd.WillDriftInYaw">
            <summary>
            Returns true if the tracker for this HMD will drift the Yaw component of its pose over time regardless of
            actual head motion. This is true for gyro-based trackers with no ground truth.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHmd.ZeroTracker">
            <summary>
            Sets the zero pose for the tracker coordinate system. After this call all WorldFromHead poses will be relative 
            to the pose whenever this was called. The new zero coordinate system will not change the fact that the Y axis is
            up in the real world, so the next pose returned from GetWorldFromHeadPose after a call to ZeroTracker may not be
            exactly an identity matrix.
            </summary>
        </member>
        <member name="M:ManagedSteam.IHmd.GetDriverId(System.String@)">
            <summary>
            The ID of the driver this HMD uses as a UTF-8 string. Returns the length of the ID in bytes. If 
            the buffer is not large enough to fit the ID an empty string will be returned. In general, 128 bytes
            will be enough to fit any ID.
            </summary>
            <param name="Buffer"></param>
            <param name="BufferLength"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHmd.GetDisplayId(System.String@)">
            <summary>
            The ID of this display within its driver this HMD uses as a UTF-8 string. Returns the length of the ID in bytes. If 
            the buffer is not large enough to fit the ID an empty string will be returned. In general, 128 bytes
            will be enough to fit any ID.
            </summary>
            <param name="Buffer"></param>
            <param name="BufferLength"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.CreateHTTPRequest(ManagedSteam.SteamTypes.HTTPMethod,System.String)">
            <summary>
            Initializes a new HTTP request, returning a handle to use in further operations on it.  Requires
            the method (GET or POST) and the absolute URL for the request.  Only http requests (ie, not https) are
            currently supported, so this string must start with http:// or https:// and should look like http://store.steampowered.com/app/250/ 
            or such.
            </summary>
            <param name="eHTTPRequestMethod"></param>
            <param name="pchAbsoluteURL"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.SetHTTPRequestContextValue(ManagedSteam.SteamTypes.HTTPRequestHandle,System.UInt64)">
            <summary>
            Set a context value for the request, which will be returned in the HTTPRequestCompleted_t callback after
            sending the request.  This is just so the caller can easily keep track of which callbacks go with which request data.
            </summary>
            <param name="hRequest"></param>
            <param name="ulContextValue"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.SetHTTPRequestNetworkActivityTimeout(ManagedSteam.SteamTypes.HTTPRequestHandle,System.UInt32)">
            <summary>
            Set a timeout in seconds for the HTTP request, must be called prior to sending the request.  Default
            timeout is 60 seconds if you don't call this.  Returns false if the handle is invalid, or the request
            has already been sent.
            </summary>
            <param name="hRequest"></param>
            <param name="unTimeoutSeconds"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.SetHTTPRequestHeaderValue(ManagedSteam.SteamTypes.HTTPRequestHandle,System.String,System.String)">
            <summary>
            Set a request header value for the request, must be called prior to sending the request.  Will 
            return false if the handle is invalid or the request is already sent.
            </summary>
            <param name="hRequest"></param>
            <param name="pchHeaderName"></param>
            <param name="pchHeaderValue"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.SetHTTPRequestGetOrPostParameter(ManagedSteam.SteamTypes.HTTPRequestHandle,System.String,System.String)">
            <summary>
            Set a GET or POST parameter value on the request, which is set will depend on the EHTTPMethod specified
            when creating the request.  Must be called prior to sending the request.  Will return false if the 
            handle is invalid or the request is already sent.
            </summary>
            <param name="hRequest"></param>
            <param name="pchParamName"></param>
            <param name="pchParamValue"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.SendHTTPRequest(ManagedSteam.SteamTypes.HTTPRequestHandle,ManagedSteam.SteamTypes.SteamAPICall@)">
            <summary>
            Sends the HTTP request, will return false on a bad handle, otherwise use SteamCallHandle to wait on
            asynchronous response via callback.
            
            Note: If the user is in offline mode in Steam, then this will add a only-if-cached cache-control 
            header and only do a local cache lookup rather than sending any actual remote request.
            </summary>
            <param name="hRequest"></param>
            <param name="pCallHandle"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.SendHTTPRequestAndStreamResponse(ManagedSteam.SteamTypes.HTTPRequestHandle,ManagedSteam.SteamTypes.SteamAPICall@)">
            <summary>
            Sends the HTTP request, will return false on a bad handle, otherwise use SteamCallHandle to wait on
            asynchronous response via callback for completion, and listen for HTTPRequestHeadersReceived_t and 
            HTTPRequestDataReceived_t callbacks while streaming.
            </summary>
            <param name="hRequest"></param>
            <param name="pCallHandle"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.DeferHTTPRequest(ManagedSteam.SteamTypes.HTTPRequestHandle)">
            <summary>
            Defers a request you have sent, the actual HTTP client code may have many requests queued, and this will move
            the specified request to the tail of the queue.  Returns false on invalid handle, or if the request is not yet sent.
            </summary>
            <param name="hRequest"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.PrioritizeHTTPRequest(ManagedSteam.SteamTypes.HTTPRequestHandle)">
            <summary>
            Prioritizes a request you have sent, the actual HTTP client code may have many requests queued, and this will move
            the specified request to the head of the queue.  Returns false on invalid handle, or if the request is not yet sent.
            </summary>
            <param name="hRequest"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.GetHTTPResponseHeaderSize(ManagedSteam.SteamTypes.HTTPRequestHandle,System.String,System.UInt32@)">
            <summary>
            Checks if a response header is present in a HTTP response given a handle from HTTPRequestCompleted_t, also 
            returns the size of the header value if present so the caller and allocate a correctly sized buffer for
            GetHTTPResponseHeaderValue.
            </summary>
            <param name="hRequest"></param>
            <param name="pchHeaderName"></param>
            <param name="unResponseHeaderSize"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.GetHTTPResponseHeaderValue(ManagedSteam.SteamTypes.HTTPRequestHandle,System.String,System.IntPtr,System.UInt32)">
            <summary>
            Gets header values from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the
            header is not present or if your buffer is too small to contain it's value.  You should first call 
            BGetHTTPResponseHeaderSize to check for the presence of the header and to find out the size buffer needed.
            </summary>
            <param name="hRequest"></param>
            <param name="pchHeaderName"></param>
            <param name="pHeaderValueBuffer"></param>
            <param name="unBufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.GetHTTPResponseBodySize(ManagedSteam.SteamTypes.HTTPRequestHandle,System.UInt32@)">
            <summary>
            Gets the size of the body data from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the 
            handle is invalid.
            </summary>
            <param name="hRequest"></param>
            <param name="unBodySize"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.GetHTTPResponseBodyData(ManagedSteam.SteamTypes.HTTPRequestHandle,System.IntPtr,System.UInt32)">
            <summary>
            Gets the body data from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the 
            handle is invalid or is to a streaming response, or if the provided buffer is not the correct size.  Use BGetHTTPResponseBodySize first to find out
            the correct buffer size to use.
            </summary>
            <param name="hRequest"></param>
            <param name="pBodyDataBuffer"></param>
            <param name="unBufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.GetHTTPStreamingResponseBodyData(ManagedSteam.SteamTypes.HTTPRequestHandle,System.UInt32,System.IntPtr,System.UInt32)">
            <summary>
            Gets the body data from a streaming HTTP response given a handle from HTTPRequestCompleted_t. Will return false if the 
            handle is invalid or is to a non-streaming response (meaning it wasn't sent with SendHTTPRequestAndStreamResponse), or if the buffer size and offset 
            do not match the size and offset sent in HTTPRequestDataReceived_t.
            </summary>
            <param name="hRequest"></param>
            <param name="cOffset"></param>
            <param name="pBodyDataBuffer"></param>
            <param name="unBufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.ReleaseHTTPRequest(ManagedSteam.SteamTypes.HTTPRequestHandle)">
            <summary>
            Releases an HTTP response handle, should always be called to free resources after receiving a HTTPRequestCompleted_t
            callback and finishing using the response.
            </summary>
            <param name="hRequest"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.GetHTTPDownloadProgressPct(ManagedSteam.SteamTypes.HTTPRequestHandle,System.Single@)">
            <summary>
            Gets progress on downloading the body for the request.  This will be zero unless a response header has already been
            received which included a content-length field.  For responses that contain no content-length it will report
            zero for the duration of the request as the size is unknown until the connection closes.
            </summary>
            <param name="hRequest"></param>
            <param name="pflPercentOut"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IHTTP.SetHTTPRequestRawPostBody(ManagedSteam.SteamTypes.HTTPRequestHandle,System.String,System.IntPtr,System.UInt32)">
            <summary>
            Sets the body for an HTTP Post request.  Will fail and return false on a GET request, and will fail if POST params
            have already been set for the request.  Setting this raw body makes it the only contents for the post, the pchContentType
            parameter will set the content-type header for the request so the server may know how to interpret the body.
            </summary>
            <param name="hRequest"></param>
            <param name="pchContentType"></param>
            <param name="pubBody"></param>
            <param name="unBodyLen"></param>
            <returns></returns>
        </member>
        <member name="T:ManagedSteam.Implementations.SteamService">
            <summary>
            \internal 
            Base for all the 'Service' classes. Can't be used outside of the wrapper library.
            </summary>
        </member>
        <member name="M:ManagedSteam.Implementations.SteamService.CheckIfUsable">
            <summary>
            This method does some general checks to see if the current instance can communicate with native dll.
            </summary>
        </member>
        <member name="T:ManagedSteam.IMatchmaking">
            <summary>
            Functions for match making services for clients to get to favorites
            and to operate on game lobbies.
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetFavoriteGameCount">
            <summary>
            returns the number of favorites servers the user has store
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetFavoriteGame(System.Int32,ManagedSteam.SteamTypes.AppID@,System.UInt32@,System.UInt16@,System.UInt16@,System.UInt32@,System.UInt32@)">
            <summary>
            returns the details of the game server
            iGame is of range [0,GetFavoriteGameCount())
            *pnIP, *pnConnPort are filled in the with IP:port of the game server
            *punFlags specify whether the game server was stored as an explicit favorite or in the history of connections
            *pRTime32LastPlayedOnServer is filled in the with the Unix time the favorite was added
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetFavoriteGame(System.Int32)">
            <summary>
            returns the details of the game server
            iGame is of range [0,GetFavoriteGameCount())
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.AddFavoriteGame(ManagedSteam.SteamTypes.AppID,System.UInt32,System.UInt16,System.UInt16,System.UInt32,System.UInt32)">
            <summary>
            adds the game server to the local list; updates the time played of the server if it already exists in the list
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.RemoveFavoriteGame(ManagedSteam.SteamTypes.AppID,System.UInt32,System.UInt16,System.UInt16,System.UInt32)">
            <summary>
            removes the game server from the local storage; returns true if one was removed
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.RequestLobbyList">
            <summary>
            Get a list of relevant lobbies
            this is an asynchronous request
            results will be returned by LobbyMatchList_t callback and call result, with the number of lobbies found
            this will never return lobbies that are full
            to add more filter, the filter calls below need to be call before each and every RequestLobbyList() call
            use the CCallResult object in steam_api.h to match the SteamAPICall_t call result to a function in an object, e.g.
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.AddRequestLobbyListStringFilter(System.String,System.String,ManagedSteam.SteamTypes.LobbyComparison)">
            <summary>
            filters for lobbies
            this needs to be called before RequestLobbyList() to take effect
            these are cleared on each call to RequestLobbyList()
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.AddRequestLobbyListNumericalFilter(System.String,System.Int32,ManagedSteam.SteamTypes.LobbyComparison)">
            <summary>
            numerical comparison
            </summary>
            <param name="KeyToMatch"></param>
            <param name="ValueToMatch"></param>
            <param name="comparisonType"></param>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.AddRequestLobbyListNearValueFilter(System.String,System.Int32)">
            <summary>
            returns results closest to the specified value. Multiple near filters can be added, with early filters taking precedence
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.AddRequestLobbyListFilterSlotsAvailable(System.Int32)">
            <summary>
            returns only lobbies with the specified number of slots available
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.AddRequestLobbyListDistanceFilter(ManagedSteam.SteamTypes.LobbyDistanceFilter)">
            <summary>
            sets the distance for which we should search for lobbies (based on users IP address to location map on the Steam backed)
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.AddRequestLobbyListResultCountFilter(System.Int32)">
            <summary>
            sets how many results to return, the lower the count the faster it is to download the lobby results and details to the client
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.AddRequestLobbyListCompatibleMembersFilter(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the CSteamID of a lobby, as retrieved by a RequestLobbyList call
            should only be called after a LobbyMatchList_t callback is received
            iLobby is of the range [0, LobbyMatchList_t::m_nLobbiesMatching)
            the returned CSteamID::IsValid() will be false if iLobby is out of range
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyByIndex(System.Int32)">
            <summary>
            returns the CSteamID of a lobby, as retrieved by a RequestLobbyList call
            should only be called after a LobbyMatchList_t callback is received
            iLobby is of the range [0, LobbyMatchList_t::m_nLobbiesMatching)
            the returned CSteamID::IsValid() will be false if iLobby is out of range
            </summary>
            <param name="lobby"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.CreateLobby(ManagedSteam.SteamTypes.LobbyType,System.Int32)">
            <summary>
            Create a lobby on the Steam servers.
            If private, then the lobby will not be returned by any RequestLobbyList() call; the CSteamID
            of the lobby will need to be communicated via game channels or via InviteUserToLobby()
            this is an asynchronous request. 
            Results will be returned by LobbyCreated_t callback and call result.
            Lobby is joinable and ready to use at this point.
            a LobbyEnter_t callback will also be received (since the local user is joining their own lobby)
            </summary>
            <param name="lobbyType"></param>
            <param name="maxMembers"></param>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.JoinLobby(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Joins an existing lobby
            this is an asynchronous request
            results will be returned by LobbyEnter_t callback and call result, check m_EChatRoomEnterResponse to see if was successful
            lobby metadata is available to use immediately on this call completing
            </summary>
            <param name="steamIDLobby"></param>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.LeaveLobby(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            eave a lobby; this will take effect immediately on the client side
            other users in the lobby will be notified by a LobbyChatUpdate_t callback
            </summary>
            <param name="steamIDLobby"></param>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.InviteUserToLobby(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Invite another user to the lobby
            the target user will receive a LobbyInvite_t callback
            will return true if the invite is successfully sent, whether or not the target responds
            returns false if the local user is not connected to the Steam servers
            if the other user clicks the join link, a GameLobbyJoinRequested_t will be posted if the user is in-game,
            or if the game isn't running yet the game will be launched with the parameter +connect_lobby (64-bit lobby id)
            </summary>
            <param name="steamIDLobby"></param>
            <param name="steamIDInvitee"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetNumLobbyMembers(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the number of users in the specified lobby
            </summary>
            <param name="steamIDLobby"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyMemberByIndex(ManagedSteam.SteamTypes.SteamID,System.Int32)">
            <summary>
            returns the CSteamID of a user in the lobby
            iMember is of range [0,GetNumLobbyMembers())
            note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby
            </summary>
            <param name="steamIDLobby"></param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyData(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            Get data associated with this lobby
            takes a simple key, and returns the string associated with it
            "" will be returned if no value is set, or if steamIDLobby is invalid
            </summary>
            <param name="steamIDLobby"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.SetLobbyData(ManagedSteam.SteamTypes.SteamID,System.String,System.String)">
             <summary>
            Sets a key/value pair in the lobby metadata
             each user in the lobby will be broadcast this new value, and any new users joining will receive any existing data
             this can be used to set lobby names, map, etc.
             to reset a key, just set it to ""
             other users in the lobby will receive notification of the lobby data change via a LobbyDataUpdate_t callback
             </summary>
             <param name="steamIDLobby"></param>
             <param name="key"></param>
             <param name="value"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyDataCount(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the number of metadata keys set on the specified lobby
            </summary>
            <param name="steamIDLobby"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyDataByIndex(ManagedSteam.SteamTypes.SteamID,System.Int32,System.String@,System.String@)">
            <summary>
            returns a lobby metadata key/values pair by index, of range [0, GetLobbyDataCount())
            </summary>
            <param name="steamIDLobby"></param>
            <param name="lobbyData"></param>
            <param name="key"></param>
            <param name="keyBufferSize"></param>
            <param name="value"></param>
            <param name="valueBufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyDataByIndex(ManagedSteam.SteamTypes.SteamID,System.Int32)">
            <summary>
            returns a lobby metadata key/values pair by index, of range [0, GetLobbyDataCount())
            </summary>
            <param name="steamIDLobby"></param>
            <param name="lobbyData"></param>
            <param name="key"></param>
            <param name="keyBufferSize"></param>
            <param name="value"></param>
            <param name="valueBufferSize"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.DeleteLobbyData(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            removes a metadata key from the lobby
            </summary>
            <param name="steamIDLobby"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyMemberData(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            Gets per-user metadata for someone in this lobby
            </summary>
            <param name="steamIDLobby"></param>
            <param name="steamIDUser"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.SetLobbyMemberData(ManagedSteam.SteamTypes.SteamID,System.String,System.String)">
            <summary>
             Sets per-user metadata (for the local user implicitly)
            </summary>
            <param name="steamIDLobby"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.SendLobbyChatMsg(ManagedSteam.SteamTypes.SteamID,System.Byte[])">
            <summary>
            Broadcasts a chat message to the all the users in the lobby
            users in the lobby (including the local user) will receive a LobbyChatMsg_t callback
            returns true if the message is successfully sent
            pvMsgBody can be binary or text data, up to 4k
            if pvMsgBody is text, cubMsgBody should be strlen( text ) + 1, to include the null terminator
            </summary>
            <param name="steamIDLobby"></param>
            <param name="msgBody"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyChatEntry(ManagedSteam.SteamTypes.SteamID,System.Int32,ManagedSteam.SteamTypes.SteamID@,System.Byte[],ManagedSteam.SteamTypes.ChatEntryType@)">
             <summary>
            Refreshes metadata for a lobby you're not necessarily in right now
             you never do this for lobbies you're a member of, only if your
             this will send down all the metadata associated with a lobby
             this is an asynchronous call
             returns false if the local user is not connected to the Steam servers
             results will be returned by a LobbyDataUpdate_t callback
             if the specified lobby doesn't exist, LobbyDataUpdate_t::m_bSuccess will be set to false
             </summary>
             <param name="steamIDLobby"></param>
             <param name="chatID"></param>
             <param name="steamIDUser"></param>
             <param name="data"></param>
             <param name="chatEntryType"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.RequestLobbyData(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Refreshes metadata for a lobby you're not necessarily in right now
            you never do this for lobbies you're a member of, only if your
            this will send down all the metadata associated with a lobby
            this is an asynchronous call
            returns false if the local user is not connected to the Steam servers
            results will be returned by a LobbyDataUpdate_t callback
            if the specified lobby doesn't exist, LobbyDataUpdate_t::m_bSuccess will be set to false
            </summary>
            <param name="steamIDLobby"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.SetLobbyGameServer(ManagedSteam.SteamTypes.SteamID,System.UInt32,System.UInt16,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            sets the game server associated with the lobby
            usually at this point, the users will join the specified game server
            either the IP/Port or the steamID of the game server has to be valid, depending on how you want the clients to be able to connect
            </summary>
            <param name="steamIDLobby"></param>
            <param name="gameServerIP"></param>
            <param name="gameServerPort"></param>
            <param name="steamIDGameServer"></param>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyGameServer(ManagedSteam.SteamTypes.SteamID,System.UInt32@,System.UInt16@,ManagedSteam.SteamTypes.SteamID@)">
            <summary>
            returns the details of a game server set in a lobby - returns false if there is no game server set, or that lobby doesn't exist
            </summary>
            <param name="steamIDLobby"></param>
            <param name="gameServerIP"></param>
            <param name="gameServerPort"></param>
            <param name="steamIDGameServer"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyGameServer(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the details of a game server set in a lobby - returns false if there is no game server set, or that lobby doesn't exist
            </summary>
            <param name="steamIDLobby"></param>
            <param name="gameServerIP"></param>
            <param name="gameServerPort"></param>
            <param name="steamIDGameServer"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.SetLobbyMemberLimit(ManagedSteam.SteamTypes.SteamID,System.Int32)">
            <summary>
            set the limit on the # of users who can join the lobby
            </summary>
            <param name="steamIDLobby"></param>
            <param name="maxMembers"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyMemberLimit(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the current limit on the # of users who can join the lobby; returns 0 if no limit is defined
            </summary>
            <param name="steamIDLobby"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.SetLobbyType(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.LobbyType)">
            <summary>
            updates which type of lobby it is
            only lobbies that are k_ELobbyTypePublic or k_ELobbyTypeInvisible, and are set to joinable, will be returned by RequestLobbyList() calls
            </summary>
            <param name="steamIDLobby"></param>
            <param name="lobbyType"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.SetLobbyJoinable(ManagedSteam.SteamTypes.SteamID,System.Boolean)">
            <summary>
            sets whether or not a lobby is joinable - defaults to true for a new lobby
            if set to false, no user can join, even if they are a friend or have been invited
            </summary>
            <param name="steamIDLobby"></param>
            <param name="lobbyJoinable"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.GetLobbyOwner(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            returns the current lobby owner
            you must be a member of the lobby to access this
            there always one lobby owner - if the current owner leaves, another user will become the owner
            it is possible (bur rare) to join a lobby just as the owner is leaving, thus entering a lobby with self as the owner
            </summary>
            <param name="steamIDLobby"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.SetLobbyOwner(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            changes who the lobby owner is
            you must be the lobby owner for this to succeed, and steamIDNewOwner must be in the lobby
            after completion, the local user will no longer be the owner
            </summary>
            <param name="steamIDLobby"></param>
            <param name="steamIDNewOwner"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmaking.SetLinkedLobby(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Link two lobbies for the purposes of checking player compatibility
            you must be the lobby owner of both lobbies
            </summary>
            <param name="steamIDLobby"></param>
            <param name="steamIDLobbyDependent"></param>
            <returns></returns>
        </member>
        <member name="T:ManagedSteam.INetworking">
            <summary>
            Purpose: interface to steam for game servers
            </summary>
        </member>
        <member name="M:ManagedSteam.INetworking.SendP2PPacket(ManagedSteam.SteamTypes.SteamID,System.IntPtr,System.UInt32,ManagedSteam.SteamTypes.P2PSend,System.Int32)">
             <summary>
             Sends a P2P packet to the specified user
             UDP-like, unreliable and a max packet size of 1200 bytes
             the first packet send may be delayed as the NAT-traversal code runs
             if we can't get through to the user, an error will be posted via the callback P2PSessionConnectFail_t
             see EP2PSend enum above for the descriptions of the different ways of sending packets
            
             nChannel is a routing number you can use to help route message to different systems 	- you'll have to call ReadP2PPacket() 
             with the same channel number in order to retrieve the data on the other end
             using different channels to talk to the same user will still use the same underlying p2p connection, saving on resource
             </summary>
             <param name="steamIDRemote"></param>
             <param name="data"></param>
             <param name="p2pSendType"></param>
             <param name="channel"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.IsP2PPacketAvailable(System.UInt32@,System.Int32)">
            <summary>
            returns true if any data is available for read, and the amount of data that will need to be read
            </summary>
            <param name="msgSize"></param>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.IsP2PPacketAvailable(System.Int32)">
            <summary>
            returns true if any data is available for read, and the amount of data that will need to be read
            </summary>
            <param name="msgSize"></param>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.ReadP2PPacket(System.Byte[],System.UInt32@,ManagedSteam.SteamTypes.SteamID@,System.Int32)">
            <summary>
            reads in a packet that has been sent from another user via SendP2PPacket()
            returns the size of the message and the steamID of the user who sent it in the last two parameters
            if the buffer passed in is too small, the message will be truncated
            this call is not blocking, and will return false if no data is available
            </summary>
            <param name="Dest"></param>
            <param name="msgSize"></param>
            <param name="steamIDRemote"></param>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.ReadP2PPacket(System.Byte[],System.Int32)">
            <summary>
            reads in a packet that has been sent from another user via SendP2PPacket()
            returns the size of the message and the steamID of the user who sent it in the last two parameters
            if the buffer passed in is too small, the message will be truncated
            this call is not blocking, and will return false if no data is available
            </summary>
            <param name="Dest"></param>
            <param name="msgSize"></param>
            <param name="steamIDRemote"></param>
            <param name="channel"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.AcceptP2PSessionWithUser(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            AcceptP2PSessionWithUser() should only be called in response to a P2PSessionRequest_t callback
            P2PSessionRequest_t will be posted if another user tries to send you a packet that you haven't talked to yet
            if you don't want to talk to the user, just ignore the request
            if the user continues to send you packets, another P2PSessionRequest_t will be posted periodically
            this may be called multiple times for a single user
            (if you've called SendP2PPacket() on the other user, this implicitly accepts the session request)
            </summary>
            <param name="steamIDRemote"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.CloseP2PSessionWithUser(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            call CloseP2PSessionWithUser() when you're done talking to a user, will free up resources under-the-hood
            if the remote user tries to send data to you again, another P2PSessionRequest_t callback will be posted
            </summary>
            <param name="steamIDRemote"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.CloseP2PChannelWithUser(ManagedSteam.SteamTypes.SteamID,System.Int32)">
            <summary>
            call CloseP2PChannelWithUser() when you're done talking to a user on a specific channel. Once all channels
            open channels to a user have been closed, the open session to the user will be closed and new data from this
            user will trigger a P2PSessionRequest_t callbac
            </summary>
            <param name="steamIDRemote"></param>
            <param name="nChannel"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.GetP2PSessionState(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.P2PSessionState@)">
            <summary>
            fills out P2PSessionState_t structure with details about the underlying connection to the user
            should only needed for debugging purposes
            returns false if no connection exists to the specified user
            </summary>
            <param name="steamIDRemote"></param>
            <param name="connectionState"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.GetP2PSessionState(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            fills out P2PSessionState_t structure with details about the underlying connection to the user
            should only needed for debugging purposes
            returns false if no connection exists to the specified user
            </summary>
            <param name="steamIDRemote"></param>
            <param name="connectionState"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.AllowP2PPacketRelay(System.Boolean)">
             <summary>
             Allow P2P connections to fall back to being relayed through the Steam servers if a direct connection
             or NAT-traversal cannot be established. Only applies to connections created after setting this value,
             or to existing connections that need to automatically reconnect after this value is set.
            
             P2P packet relay is allowed by default
             </summary>
             <param name="allow"></param>
             <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.CreateListenSocket(System.Int32,System.UInt32,System.UInt16,System.Boolean)">
            <summary>
            creates a socket and listens others to connect
            will trigger a SocketStatusCallback_t callback on another client connecting
            nVirtualP2PPort is the unique ID that the client will connect to, in case you have multiple ports
            	this can usually just be 0 unless you want multiple sets of connections
            unIP is the local IP address to bind to
            	pass in 0 if you just want the default local IP
            unPort is the port to use
            	pass in 0 if you don't want users to be able to connect via IP/Port, but expect to be always peer-to-peer connections only
            </summary>
            <param name="virtualP2PPort"></param>
            <param name="IP"></param>
            <param name="port"></param>
            <param name="allowUseOfPacketRelay"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.CreateP2PConnectionSocket(ManagedSteam.SteamTypes.SteamID,System.Int32,System.Int32,System.Boolean)">
            <summary>
            creates a socket and begin connection to a remote destination
            can connect via a known steamID (client or game server), or directly to an IP
            on success will trigger a SocketStatusCallback_t callback
            on failure or timeout will trigger a SocketStatusCallback_t callback with a failure code in m_eSNetSocketStat
            </summary>
            <param name="steamIDTarget"></param>
            <param name="virtualPort"></param>
            <param name="timeoutSec"></param>
            <param name="allowUseOfPacketRelay"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.CreateConnectionSocket(System.UInt32,System.UInt16,System.Int32)">
            <summary>
            creates a socket and begin connection to a remote destination
            can connect via a known steamID (client or game server), or directly to an IP
            on success will trigger a SocketStatusCallback_t callback
            on failure or timeout will trigger a SocketStatusCallback_t callback with a failure code in m_eSNetSocketState
            </summary>
            <param name="nIP"></param>
            <param name="nPort"></param>
            <param name="nTimeoutSec"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.DestroySocket(ManagedSteam.SteamTypes.NetSocketHandle,System.Boolean)">
            <summary>
            disconnects the connection to the socket, if any, and invalidates the handle
            any unread data on the socket will be thrown away
            if bNotifyRemoteEnd is set, socket will not be completely destroyed until the remote end acknowledges the disconnect
            </summary>
            <param name="socket"></param>
            <param name="notifyRemoteEnd"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.DestroyListenSocket(ManagedSteam.SteamTypes.NetListenSocketHandle,System.Boolean)">
            <summary>
            destroying a listen socket will automatically kill all the regular sockets generated from it
            </summary>
            <param name="socket"></param>
            <param name="notifyRemoteEnd"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.SendDataOnSocket(ManagedSteam.SteamTypes.NetSocketHandle,System.Byte[],System.Boolean)">
            <summary>
            sending data
            must be a handle to a connected socket
            data is all sent via UDP, and thus send sizes are limited to 1200 bytes; after this, many routers will start dropping packets
            use the reliable flag with caution; although the resend rate is pretty aggressive,
            it can still cause stalls in receiving data (like TCP)
            </summary>
            <param name="socket"></param>
            <param name="data"></param>
            <param name="reliable"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.IsDataAvailableOnSocket(ManagedSteam.SteamTypes.NetSocketHandle,System.UInt32@)">
            <summary>
            receiving data
            returns false if there is no data remaining
            fills out *pcubMsgSize with the size of the next message, in bytes
            </summary>
            <param name="socket"></param>
            <param name="msgSize"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ManagedSteam.INetworking.IsDataAvailableOnSocket(ManagedSteam.SteamTypes.NetSocketHandle)" -->
        <member name="M:ManagedSteam.INetworking.RetrieveDataFromSocket(ManagedSteam.SteamTypes.NetSocketHandle,System.Byte[],System.UInt32@)">
            <summary>
            fills in pubDest with the contents of the message
            messages are always complete, of the same size as was sent (i.e. packetized, not streaming)
            if *pcubMsgSize  cubDest, only partial data is written
            returns false if no data is available
            </summary>
            <param name="socket"></param>
            <param name="dest"></param>
            <param name="msgSize"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.RetrieveDataFromSocket(ManagedSteam.SteamTypes.NetSocketHandle,System.Byte[])">
            <summary>
            fills in pubDest with the contents of the message
            messages are always complete, of the same size as was sent (i.e. packetized, not streaming)
            if *pcubMsgSize  cubDest, only partial data is written
            returns false if no data is available
            </summary>
            <param name="socket"></param>
            <param name="dest"></param>
            <param name="msgSize"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.IsDataAvailable(ManagedSteam.SteamTypes.NetListenSocketHandle,System.UInt32@,ManagedSteam.SteamTypes.NetSocketHandle@)">
            <summary>
            checks for data from any socket that has been connected off this listen socket
            returns false if there is no data remaining
            fills out *pcubMsgSize with the size of the next message, in bytes
            fills out *phSocket with the socket that data is available on
            </summary>
            <param name="listenSocket"></param>
            <param name="msgSize"></param>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.IsDataAvailable(ManagedSteam.SteamTypes.NetListenSocketHandle)">
            <summary>
            checks for data from any socket that has been connected off this listen socket
            returns false if there is no data remaining
            fills out *pcubMsgSize with the size of the next message, in bytes
            fills out *phSocket with the socket that data is available on
            </summary>
            <param name="listenSocket"></param>
            <param name="msgSize"></param>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.RetrieveData(ManagedSteam.SteamTypes.NetListenSocketHandle,System.Byte[],System.UInt32@,ManagedSteam.SteamTypes.NetSocketHandle@)">
            <summary>
            retrieves data from any socket that has been connected off this listen socket
            fills in pubDest with the contents of the message
            messages are always complete, of the same size as was sent (i.e. packetized, not streaming)
            if *pcubMsgSize cubDest, only partial data is written
            returns false if no data is available
            fills out *phSocket with the socket that data is available on
            </summary>
            <param name="listenSocket"></param>
            <param name="dest"></param>
            <param name="cubDest"></param>
            <param name="msgSize"></param>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.RetrieveData(ManagedSteam.SteamTypes.NetListenSocketHandle,System.Byte[])">
            <summary>
            retrieves data from any socket that has been connected off this listen socket
            fills in pubDest with the contents of the message
            messages are always complete, of the same size as was sent (i.e. packetized, not streaming)
            if *pcubMsgSize cubDest, only partial data is written
            returns false if no data is available
            fills out *phSocket with the socket that data is available on
            </summary>
            <param name="listenSocket"></param>
            <param name="dest"></param>
            <param name="cubDest"></param>
            <param name="msgSize"></param>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.GetSocketInfo(ManagedSteam.SteamTypes.NetSocketHandle,ManagedSteam.SteamTypes.SteamID@,ManagedSteam.SteamTypes.SNetSocketState@,System.UInt32@,System.UInt16@)">
            <summary>
            returns information about the specified socket, filling out the contents of the pointers
            </summary>
            <param name="socket"></param>
            <param name="steamIDRemote"></param>
            <param name="socketStatus"></param>
            <param name="ipRemote"></param>
            <param name="portRemote"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.GetSocketInfo(ManagedSteam.SteamTypes.NetSocketHandle)">
            <summary>
            returns information about the specified socket, filling out the contents of the pointers
            </summary>
            <param name="socket"></param>
            <param name="steamIDRemote"></param>
            <param name="socketStatus"></param>
            <param name="ipRemote"></param>
            <param name="portRemote"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.GetListenSocketInfo(ManagedSteam.SteamTypes.NetListenSocketHandle,System.UInt32@,System.UInt16@)">
            <summary>
            returns which local port the listen socket is bound to
            *pnIP and *pnPort will be 0 if the socket is set to listen for P2P connections only
            </summary>
            <param name="hListenSocket"></param>
            <param name="ip"></param>
            <param name="port"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.GetListenSocketInfo(ManagedSteam.SteamTypes.NetListenSocketHandle)">
            <summary>
            returns which local port the listen socket is bound to
            *pnIP and *pnPort will be 0 if the socket is set to listen for P2P connections only
            </summary>
            <param name="hListenSocket"></param>
            <param name="ip"></param>
            <param name="port"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.GetSocketConnectionType(ManagedSteam.SteamTypes.NetSocketHandle)">
            <summary>
            returns true to describe how the socket ended up connecting
            </summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.INetworking.GetMaxPacketSize(ManagedSteam.SteamTypes.NetSocketHandle)">
            <summary>
            max packet size, in bytes
            </summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IScreenshots.WriteScreenshot(System.IntPtr,System.UInt32,System.Int32,System.Int32)">
            <summary>
            Writes a screenshot to the user's screenshot library given the raw image data, which must be in RGB format.
            The return value is a handle that is valid for the duration of the game process and can be used to apply tags.
            </summary>
            <param name="pubRGB"></param>
            <param name="cubRGB"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IScreenshots.AddScreenshotToLibrary(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            Adds a screenshot to the user's screenshot library from disk.  If a thumbnail is provided, it must be 200 pixels wide and the same aspect ratio
            as the screenshot, otherwise a thumbnail will be generated if the user uploads the screenshot.  The screenshots must be in either JPEG or TGA format.
            The return value is a handle that is valid for the duration of the game process and can be used to apply tags.
            JPEG, TGA, and PNG formats are supported.
            </summary>
            <param name="filename"></param>
            <param name="thumbnailFilename"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IScreenshots.TriggerScreenshot">
            <summary>
            Causes the Steam overlay to take a screenshot.  If screenshots are being hooked by the game then a ScreenshotRequested_t callback is sent back to the game instead. 
            </summary>
        </member>
        <member name="M:ManagedSteam.IScreenshots.HookScreenshots(System.Boolean)">
            <summary>
            Toggles whether the overlay handles screenshots when the user presses the screenshot hotkey, or the game handles them.  If the game is hooking screenshots,
            then the ScreenshotRequested_t callback will be sent if the user presses the hotkey, and the game is expected to call WriteScreenshot or AddScreenshotToLibrary
            in response.
            </summary>
            <param name="hook"></param>
        </member>
        <member name="M:ManagedSteam.IScreenshots.SetLocation(ManagedSteam.SteamTypes.ScreenshotHandle,System.String)">
            <summary>
            Sets metadata about a screenshot's location (for example, the name of the map)
            </summary>
            <param name="screenshot"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IScreenshots.TagUser(ManagedSteam.SteamTypes.ScreenshotHandle,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Tags a user as being visible in the screenshot
            </summary>
            <param name="screenshot"></param>
            <param name="steamID"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IScreenshots.TagPublishedFile(ManagedSteam.SteamTypes.ScreenshotHandle,ManagedSteam.SteamTypes.PublishedFileId)">
            <summary>
            Tags a published file as being visible in the screenshot
            </summary>
            <param name="screenshot"></param>
            <param name="publishedFileID"></param>
            <returns></returns>
        </member>
        <member name="T:ManagedSteam.IStats">
            <summary>
            Handles stats, leaderboards and achievements.
            Wraps ISteamUserStats.
            
            \note
            GetAchievementIcon is not implemented in this release
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.RequestCurrentStats">
            <summary>
            \lite
            Available in Lite
            \endlite
            
            
            Ask the server to send down this user's data and achievements for this game
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetStat(System.String,System.Int32@)">
            <summary>
            \lite
            Available in Lite
            \endlite
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetStat(System.String,System.Single@)">
            <summary>
            \lite
            Available in Lite
            \endlite
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.SetStat(System.String,System.Int32)">
            <summary>
            \lite
            Available in Lite
            \endlite
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.SetStat(System.String,System.Single)">
            <summary>
            \lite
            Available in Lite
            \endlite
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.UpdateAverageRateStat(System.String,System.Single,System.Double)">
            <summary>
            \lite
            Available in Lite
            \endlite
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetAchievementAndUnlockTime(System.String,System.Boolean@,System.UInt32@)">
            <summary>
            Get the achievement status, and the time it was unlocked if unlocked.
            If the return value is true, but the unlock time is zero, that means it was unlocked before Steam 
            began tracking achievement unlock times (December 2009). Time is seconds since January 1, 1970. 
            </summary>
            <param name="name"></param>
            <param name="achieved"></param>
            <param name="unlockTime"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.StoreStats">
             <summary>
             \lite 
             Available in Lite
             \endlite
             Store the current data on the server, will get a callback when set
             And one callback for every new achievement
            
             If the callback has a result of k_EResultInvalidParam, one or more stats 
             uploaded has been rejected, either because they broke constraints
             or were out of date. In this case the server sends back updated values.
             The stats should be re-iterated to keep in sync.
             </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetAchievementDisplayAttribute(System.String,System.String)">
            <summary>
            Get general attributes for an achievement. Accepts the following keys:
            - "name" and "desc" for retrieving the localized achievement name and description (returned in UTF8)
            - "hidden" for retrieving if an achievement is hidden (returns "0" when not hidden, "1" when hidden) 
            </summary>
            <param name="name"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.IndicateAchievementProgress(System.String,System.UInt32,System.UInt32)">
            <summary>
            Achievement progress - triggers an AchievementProgress callback, that is all.
            Calling this w/ N out of N progress will NOT set the achievement, the game must still do that. 
            </summary>
            <param name="name"></param>
            <param name="currentProgress"></param>
            <param name="maxProgress"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.RequestUserStats(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            \lite 
            Available in Lite
            \endlite
            downloads stats for the user
            returns a UserStatsReceived_t received when completed
            if the other user has no stats, UserStatsReceived_t.m_eResult will be set to k_EResultFail
            these stats won't be auto-updated; you'll need to call RequestUserStats() again to refresh any data
            </summary>
            <param name="steamID"></param>
        </member>
        <member name="M:ManagedSteam.IStats.GetUserStat(ManagedSteam.SteamTypes.SteamID,System.String,System.Int32@)">
            <summary>
            \lite
            Available in Lite
            \endlite
            requests stat information for a user, usable after a successful call to RequestUserStats()
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetUserStatInt(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            \lite
            Available in Lite
            \endlite
            requests stat information for a user, usable after a successful call to RequestUserStats()
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetUserStat(ManagedSteam.SteamTypes.SteamID,System.String,System.Single@)">
            <summary>
            \lite
            Available in Lite
            \endlite
            requests stat information for a user, usable after a successful call to RequestUserStats()
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetUserStatFloat(ManagedSteam.SteamTypes.SteamID,System.String)">
            <summary>
            \lite
            Available in Lite
            \endlite
            requests stat information for a user, usable after a successful call to RequestUserStats()
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.ResetAllStats(System.Boolean)">
            <summary>
            \lite
            Available in Lite
            \endlite
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.FindOrCreateLeaderboard(System.String,ManagedSteam.SteamTypes.LeaderboardSortMethod,ManagedSteam.SteamTypes.LeaderboardDisplayType)">
            <summary>
            Invokes LeaderboardFindResult.
            asks the Steam back-end for a leaderboard by name, and will create it if it's not yet
            This call is asynchronous, with the result returned in LeaderboardFindResult_t
            </summary>
            <param name="name"></param>
            <param name="sortMethod"></param>
            <param name="displayType"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ManagedSteam.IStats.FindLeaderboard(System.String)" -->
        <member name="M:ManagedSteam.IStats.GetLeaderboardName(ManagedSteam.SteamTypes.LeaderboardHandle)">
            <summary>
            returns the name of a leaderboard
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.GetLeaderboardEntryCount(ManagedSteam.SteamTypes.LeaderboardHandle)">
            <summary>
            returns the total number of entries in a leaderboard, as of the last request
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.GetLeaderboardSortMethod(ManagedSteam.SteamTypes.LeaderboardHandle)">
            <summary>
            returns the sort method of the leaderboard
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.GetLeaderboardDisplayType(ManagedSteam.SteamTypes.LeaderboardHandle)">
            <summary>
            returns the display type of the leaderboard 
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ManagedSteam.IStats.DownloadLeaderboardEntries(ManagedSteam.SteamTypes.LeaderboardHandle,ManagedSteam.SteamTypes.LeaderboardDataRequest,System.Int32,System.Int32)" -->
        <member name="M:ManagedSteam.IStats.DownloadLeaderboardEntriesForUsers(ManagedSteam.SteamTypes.LeaderboardHandle,ManagedSteam.SteamTypes.SteamID[])">
            <summary>
            as above, but downloads leaderboard entries for an arbitrary set of users - ELeaderboardDataRequest is k_ELeaderboardDataRequestUsers
            if a user doesn't have a leaderboard entry, they won't be included in the result
            a max of 100 users can be downloaded at a time, with only one outstanding call at a time
            </summary>
            <param name="handle"></param>
            <param name="users"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ManagedSteam.IStats.GetDownloadedLeaderboardEntry(ManagedSteam.SteamTypes.LeaderboardEntriesHandle,System.Int32,ManagedSteam.SteamTypes.LeaderboardEntry@,System.Int32[])" -->
        <member name="M:ManagedSteam.IStats.UploadLeaderboardScore(ManagedSteam.SteamTypes.LeaderboardHandle,ManagedSteam.SteamTypes.LeaderboardUploadScoreMethod,System.Int32,System.Int32[])">
            <summary>
            Invokes LeaderboardScoreUploaded
            Uploads a user score to the Steam back-end.
            This call is asynchronous, with the result returned in LeaderboardScoreUploaded_t
            Details are extra game-defined information regarding how the user got that score
            pScoreDetails points to an array of int32's, cScoreDetailsCount is the number of int32's in the list
            </summary>
            <param name="handle"></param>
            <param name="scoreMethod"></param>
            <param name="score"></param>
            <param name="details"></param>
        </member>
        <member name="M:ManagedSteam.IStats.AttachLeaderboardUGC(ManagedSteam.SteamTypes.LeaderboardHandle,ManagedSteam.SteamTypes.UGCHandle)">
            <summary>
            Invokes LeaderboardUGCSet
            attaches a piece of user generated content the user's entry on a leaderboard.
            hContent is a handle to a piece of user generated content that was shared using ISteamUserRemoteStorage::FileShare().
            This call is asynchronous, with the result returned in LeaderboardUGCSet_t.
            </summary>
            <param name="handle"></param>
            <param name="ugcHandle"></param>
        </member>
        <member name="M:ManagedSteam.IStats.GetNumberOfCurrentPlayers">
            <summary>
            Invokes NumberOfCurrentPlayers
            Retrieves the number of players currently playing your game (online + offline)
            This call is asynchronous, with the result returned in NumberOfCurrentPlayers_t
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.RequestGlobalAchievementPercentages">
            <summary>
            Invokes GlobalAchievementPercentagesReady
            Requests that Steam fetch data on the percentage of players who have received each achievement
            for the game globally.
            This call is asynchronous, with the result returned in GlobalAchievementPercentagesReady_t.
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetMostAchievedAchievementInfo(System.String@,System.Single@,System.Boolean@)">
            <summary>
            Get the info on the most achieved achievement for the game, returns an iterator index you can use to fetch
            the next most achieved afterwards.  Will return -1 if there is no data on achievement 
            percentages (ie, you haven't called RequestGlobalAchievementPercentages and waited on the callback).
            </summary>
            <param name="name"></param>
            <param name="percent"></param>
            <param name="achieved"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.GetMostAchievedAchievementInfo">
            <summary>
            Get the info on the most achieved achievement for the game, returns an iterator index you can use to fetch
            the next most achieved afterwards.  Will return -1 if there is no data on achievement 
            percentages (ie, you haven't called RequestGlobalAchievementPercentages and waited on the callback).
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.GetNextMostAchievedAchievementInfo(System.Int32,System.String@,System.Single@,System.Boolean@)">
            <summary>
            Get the info on the next most achieved achievement for the game. Call this after GetMostAchievedAchievementInfo or another
            GetNextMostAchievedAchievementInfo call passing the iterator from the previous call. Returns -1 after the last
            achievement has been iterated.
            </summary>
            <param name="iterator"></param>
            <param name="name"></param>
            <param name="percent"></param>
            <param name="achieved"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.GetNextMostAchievedAchievementInfo(System.Int32)">
            <summary>
            Get the info on the next most achieved achievement for the game. Call this after GetMostAchievedAchievementInfo or another
            GetNextMostAchievedAchievementInfo call passing the iterator from the previous call. Returns -1 after the last
            achievement has been iterated.
            </summary>
            <param name="iterator"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.GetAchievementAchievedPercent(System.String,System.Single@)">
            <summary>
            Returns the percentage of users who have achieved the specified achievement.
            </summary>
            <param name="name"></param>
            <param name="percent"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.GetAchievementAchievedPercent(System.String)">
            <summary>
            Returns the percentage of users who have achieved the specified achievement.
            </summary>
            <param name="name"></param>
            <param name="percent"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IStats.RequestGlobalStats(System.Int32)">
            <summary>
            \lite 
            Available in Lite
            \endlite
            Requests global stats data, which is available for stats marked as "aggregated".
            This call is asynchronous, with the results returned in GlobalStatsReceived_t.
            nHistoryDays specifies how many days of day-by-day history to retrieve in addition
            to the overall totals. The limit is 60.
            Invokes GlobalStatsReceived.
            </summary>
            <param name="historyDays"></param>
        </member>
        <member name="M:ManagedSteam.IStats.GetGlobalStat(System.String,System.Int64@)">
            <summary>
            \lite
            Available in Lite
            \endlite
            Gets the lifetime totals for an aggregated stat
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetGlobalStatLong(System.String)">
            <summary>
            \lite
            Available in Lite
            \endlite
            Gets the lifetime totals for an aggregated stat
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetGlobalStat(System.String,System.Double@)">
            <summary>
            \lite
            Available in Lite
            \endlite
            Gets the lifetime totals for an aggregated stat
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetGlobalStatDouble(System.String)">
            <summary>
            \lite
            Available in Lite
            \endlite
            Gets the lifetime totals for an aggregated stat
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetGlobalStatHistory(System.String,System.Int64[]@,System.Int32)">
            <summary>
            \lite
            Available in Lite
            \endlite
            Gets history for an aggregated stat. pData will be filled with daily values, starting with today.
            So when called, pData[0] will be today, pData[1] will be yesterday, and pData[2] will be two days ago, 
            etc. cubData is the size in bytes of the pubData buffer. Returns the number of 
            elements actually set.
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetGlobalStatHistoryLong(System.String,System.Int32)">
            <summary>
            \lite
            Available in Lite
            \endlite
            Gets history for an aggregated stat. pData will be filled with daily values, starting with today.
            So when called, pData[0] will be today, pData[1] will be yesterday, and pData[2] will be two days ago, 
            etc. cubData is the size in bytes of the pubData buffer. Returns the number of 
            elements actually set.
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetGlobalStatHistory(System.String,System.Double[]@,System.Int32)">
            <summary>
            \lite
            Available in Lite
            \endlite
            Gets history for an aggregated stat. pData will be filled with daily values, starting with today.
            So when called, pData[0] will be today, pData[1] will be yesterday, and pData[2] will be two days ago, 
            etc. cubData is the size in bytes of the pubData buffer. Returns the number of 
            elements actually set.
            </summary>
        </member>
        <member name="M:ManagedSteam.IStats.GetGlobalStatHistoryDouble(System.String,System.Int32)">
            <summary>
            \lite
            Available in Lite
            \endlite
            Gets history for an aggregated stat. pData will be filled with daily values, starting with today.
            So when called, pData[0] will be today, pData[1] will be yesterday, and pData[2] will be two days ago, 
            etc. cubData is the size in bytes of the pubData buffer. Returns the number of 
            elements actually set.
            </summary>
        </member>
        <member name="E:ManagedSteam.IStats.UserStatsReceived">
            <summary>
            Invoked by RequestUserStats() and RequestCurrentStats()
            </summary>
        </member>
        <member name="E:ManagedSteam.IStats.UserStatsStored">
            <summary>
            Invoked by StoreStats()
            </summary>
        </member>
        <member name="E:ManagedSteam.IStats.UserAchievementStored">
            <summary>
            Invoked by StoreStats()
            </summary>
        </member>
        <member name="E:ManagedSteam.IStats.LeaderboardFindResult">
            <summary>
            Invoked by FindOrCreateLeaderboard() and FindLeaderboard()
            </summary>
        </member>
        <member name="E:ManagedSteam.IStats.LeaderboardScoresDownloaded">
            <summary>
            Invoked by DownloadLeaderboardEntries() and DownloadLeaderboardEntriesForUsers()
            </summary>
        </member>
        <member name="E:ManagedSteam.IStats.LeaderboardScoreUploaded">
            <summary>
            Invoked by UploadLeaderboardScore()
            </summary>
        </member>
        <member name="E:ManagedSteam.IStats.LeaderboardUGCSet">
            <summary>
            Invoked by AttachLeaderboardUGC()
            </summary>
        </member>
        <member name="E:ManagedSteam.IStats.NumberOfCurrentPlayers">
            <summary>
            Invoked by GetNumberOfCurrentPlayers()
            </summary>
        </member>
        <member name="E:ManagedSteam.IStats.GlobalAchievementPercentagesReady">
            <summary>
            Invoked by RequestGlobalAchievementPercentages()
            </summary>
        </member>
        <member name="E:ManagedSteam.IStats.GlobalStatsReceived">
            <summary>
            Invoked by RequestGlobalStats()
            </summary>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.StoreStats">
            <summary>
            Invokes UserStatsStored
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.GetAchievementDisplayAttribute(System.String,System.String)">
            <summary>
            Gets the icon of the achievement, which is a handle to be used in ISteamUtils::GetImageRGBA(), or 0 if none set. 
            A return value of 0 may indicate we are still fetching data, and you can wait for the UserAchievementIconFetched_t callback
            which will notify you when the bits are ready. If the callback still returns zero, then there is no image set for the
            specified achievement.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.RequestUserStats(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Invokes UserStatsReceived
            </summary>
            <param name="steamID"></param>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.FindOrCreateLeaderboard(System.String,ManagedSteam.SteamTypes.LeaderboardSortMethod,ManagedSteam.SteamTypes.LeaderboardDisplayType)">
            <summary>
            Invokes LeaderboardFindResult.
            </summary>
            <param name="name"></param>
            <param name="sortMethod"></param>
            <param name="displayType"></param>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.FindLeaderboard(System.String)">
            <summary>
            Invokes LeaderboardFindResult.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.DownloadLeaderboardEntries(ManagedSteam.SteamTypes.LeaderboardHandle,ManagedSteam.SteamTypes.LeaderboardDataRequest,System.Int32,System.Int32)">
            <summary>
            Invokes LeaderboardScoresDownloaded
            </summary>
            <param name="handle"></param>
            <param name="dataRequest"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.DownloadLeaderboardEntriesForUsers(ManagedSteam.SteamTypes.LeaderboardHandle,ManagedSteam.SteamTypes.SteamID[])">
            <summary>
            Invokes LeaderboardScoresDownloaded
            </summary>
            <param name="handle"></param>
            <param name="users"></param>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.UploadLeaderboardScore(ManagedSteam.SteamTypes.LeaderboardHandle,ManagedSteam.SteamTypes.LeaderboardUploadScoreMethod,System.Int32,System.Int32[])">
            <summary>
            Invokes LeaderboardScoreUploaded
            </summary>
            <param name="handle"></param>
            <param name="scoreMethod"></param>
            <param name="score"></param>
            <param name="details"></param>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.AttachLeaderboardUGC(ManagedSteam.SteamTypes.LeaderboardHandle,ManagedSteam.SteamTypes.UGCHandle)">
            <summary>
            Invokes LeaderboardUGCSet
            </summary>
            <param name="handle"></param>
            <param name="ugcHandle"></param>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.GetNumberOfCurrentPlayers">
            <summary>
            Invokes NumberOfCurrentPlayers
            </summary>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.RequestGlobalAchievementPercentages">
            <summary>
            Invokes GlobalAchievementPercentagesReady
            </summary>
        </member>
        <member name="M:ManagedSteam.Implementations.Stats.RequestGlobalStats(System.Int32)">
            <summary>
            Invokes GlobalStatsReceived
            </summary>
            <param name="historyDays"></param>
        </member>
        <member name="E:ManagedSteam.Implementations.Stats.UserStatsReceived">
            <summary>
            Invoked by RequestUserStats()
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Stats.UserStatsStored">
            <summary>
            Invoked by StoreStats()
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Stats.UserAchievementStored">
            <summary>
            Invoked by StoreStats()
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Stats.LeaderboardFindResult">
            <summary>
            Invoked by FindOrCreateLeaderboard() and FindLeaderboard()
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Stats.LeaderboardScoresDownloaded">
            <summary>
            Invoked by DownloadLeaderboardEntries() and DownloadLeaderboardEntriesForUsers()
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Stats.LeaderboardScoreUploaded">
            <summary>
            Invoked by UploadLeaderboardScore()
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Stats.LeaderboardUGCSet">
            <summary>
            Invoked by AttachLeaderboardUGC()
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Stats.NumberOfCurrentPlayers">
            <summary>
            Invoked by GetNumberOfCurrentPlayers()
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Stats.GlobalAchievementPercentagesReady">
            <summary>
            Invoked by RequestGlobalAchievementPercentages()
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Stats.GlobalStatsReceived">
            <summary>
            Invoked by RequestGlobalStats()
            </summary>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.RequestInternetServerList(ManagedSteam.SteamTypes.AppID,ManagedSteam.SteamTypes.MatchMakingKeyValuePair[],ManagedSteam.MatchmakingServerListResponse)">
            <summary>
            Request a new list of servers of the interney type. 
            Each call allocates a new asynchronous request object.
            Request object must be released by calling ReleaseRequest( hServerListRequest )
            </summary>
            <param name="appID"></param>
            <param name="filters"></param>
            <param name="requestServersResponse"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.RequestLANServerList(ManagedSteam.SteamTypes.AppID,ManagedSteam.MatchmakingServerListResponse)">
            <summary>
            Request a new list of servers of the interney type. 
            Each call allocates a new asynchronous request object.
            Request object must be released by calling ReleaseRequest( hServerListRequest )
            </summary>
            <param name="appID"></param>
            <param name="requestServersResponse"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.RequestFriendsServerList(ManagedSteam.SteamTypes.AppID,ManagedSteam.SteamTypes.MatchMakingKeyValuePair[],ManagedSteam.MatchmakingServerListResponse)">
            <summary>
            Request a new list of servers of the interney type. 
            Each call allocates a new asynchronous request object.
            Request object must be released by calling ReleaseRequest( hServerListRequest )
            </summary>
            <param name="appID"></param>
            <param name="filters"></param>
            <param name="requestServersResponse"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.RequestFavoritesServerList(ManagedSteam.SteamTypes.AppID,ManagedSteam.SteamTypes.MatchMakingKeyValuePair[],ManagedSteam.MatchmakingServerListResponse)">
            <summary>
            Request a new list of servers of the interney type. 
            Each call allocates a new asynchronous request object.
            Request object must be released by calling ReleaseRequest( hServerListRequest )
            </summary>
            <param name="appID"></param>
            <param name="filters"></param>
            <param name="requestServersResponse"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.RequestHistoryServerList(ManagedSteam.SteamTypes.AppID,ManagedSteam.SteamTypes.MatchMakingKeyValuePair[],ManagedSteam.MatchmakingServerListResponse)">
            <summary>
            Request a new list of servers of the interney type. 
            Each call allocates a new asynchronous request object.
            Request object must be released by calling ReleaseRequest( hServerListRequest )
            </summary>
            <param name="appID"></param>
            <param name="filters"></param>
            <param name="requestServersResponse"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.RequestSpectatorServerList(ManagedSteam.SteamTypes.AppID,ManagedSteam.SteamTypes.MatchMakingKeyValuePair[],ManagedSteam.MatchmakingServerListResponse)">
            <summary>
            Request a new list of servers of the interney type. 
            Each call allocates a new asynchronous request object.
            Request object must be released by calling ReleaseRequest( hServerListRequest )
            </summary>
            <param name="appID"></param>
            <param name="filters"></param>
            <param name="requestServersResponse"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.ReleaseRequest(ManagedSteam.SteamTypes.ServerListRequestHandle)">
            <summary>
            Releases the asynchronous request object and cancels any pending query on it if there's a pending query in progress.
            RefreshComplete callback is not posted when request is released.
            </summary>
            <param name="serverListRequest"></param>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.GetServerDetails(ManagedSteam.SteamTypes.ServerListRequestHandle,System.Int32)">
            <summary>
            Get details on a given server in the list, you can get the valid range of index
            values by calling GetServerCount().  You will also receive index values in 
            ISteamMatchmakingServerListResponse::ServerResponded() callbacks
            </summary>
            <param name="request"></param>
            <param name="server"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.CancelQuery(ManagedSteam.SteamTypes.ServerListRequestHandle)">
            <summary>
            Cancel an request which is operation on the given list type.  You should call this to cancel
            any in-progress requests before destructing a callback object that may have been passed 
            to one of the above list request calls.  Not doing so may result in a crash when a callback
            occurs on the destructed object.
            Canceling a query does not release the allocated request handle.
            The request handle must be released using ReleaseRequest( hRequest )
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.RefreshQuery(ManagedSteam.SteamTypes.ServerListRequestHandle)">
            <summary>
            Ping every server in your list again but don't update the list of servers
            Query callback installed when the server list was requested will be used
            again to post notifications and RefreshComplete, so the callback must remain
            valid until another RefreshComplete is called on it or the request
            is released with ReleaseRequest( hRequest )
            </summary>
            <param name="request"></param>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.PingServer(System.UInt32,System.UInt16,ManagedSteam.MatchmakingPingResponse)">
            <summary>
            Request updated ping time and other details from a single server
            </summary>
            <param name="ip"></param>
            <param name="port"></param>
            <param name="requestServersResponse"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.PlayerDetails(System.UInt32,System.UInt16,ManagedSteam.MatchmakingPlayersResponse)">
            <summary>
            Request the list of players currently playing on a server
            </summary>
            <param name="ip"></param>
            <param name="port"></param>
            <param name="requestServersResponse"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.ServerRules(System.UInt32,System.UInt16,ManagedSteam.MatchmakingRulesResponse)">
            <summary>
            Request the list of rules that the server is running (See ISteamGameServer::SetKeyValue() to set the rules server side)
            </summary>
            <param name="ip"></param>
            <param name="port"></param>
            <param name="requestServersResponse"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IMatchmakingServers.CancelServerQuery(ManagedSteam.SteamTypes.ServerQueryHandle)">
            <summary>
            Cancel an outstanding Ping/Players/Rules query from above.  You should call this to cancel
            any in-progress requests before destructing a callback object that may have been passed 
            to one of the above calls to avoid crashing when callbacks occur.
            </summary>
            <param name="hServerQuery"></param>
        </member>
        <member name="M:ManagedSteam.IUGC.CreateQueryUserUGCRequest(ManagedSteam.SteamTypes.AccountID,ManagedSteam.SteamTypes.UserUGCList,ManagedSteam.SteamTypes.EUGCMatchingUGCType,ManagedSteam.SteamTypes.EUserUGCListSortOrder,ManagedSteam.SteamTypes.AppID,ManagedSteam.SteamTypes.AppID,System.UInt32)">
            <summary>
            Query UGC associated with a user. Creator app id or consumer app id must be valid and be set to the current running app.
            </summary>
            <param name="accountId"></param>
            <param name="listType"></param>
            <param name="matchingUGCType"></param>
            <param name="sortOrder"></param>
            <param name="creatorAppID"></param>
            <param name="consumerAppID"></param>
            <param name="page"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IUGC.CreateQueryAllUGCRequest(ManagedSteam.SteamTypes.EUGCQuery,ManagedSteam.SteamTypes.EUGCMatchingUGCType,ManagedSteam.SteamTypes.AppID,ManagedSteam.SteamTypes.AppID,System.UInt32)">
            <summary>
            Query for all matching UGC. Creator app id or consumer app id must be valid and be set to the current running app.
            </summary>
            <param name="queryType"></param>
            <param name="matchingeMatchingUGCTypeFileType"></param>
            <param name="creatorAppID"></param>
            <param name="consumerAppID"></param>
            <param name="page"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IUGC.SendQueryUGCRequest(ManagedSteam.SteamTypes.UGCQueryHandle)">
            <summary>
            Send the query to Steam
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:ManagedSteam.IUGC.GetQueryUGCResult(ManagedSteam.SteamTypes.UGCQueryHandle,System.UInt32,ManagedSteam.SteamTypes.UGCDetails@)">
            <summary>
            Retrieve an individual result after receiving the callback for querying UGC
            </summary>
            <param name="handle"></param>
            <param name="index"></param>
            <param name="details"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IUGC.GetQueryUGCResult(ManagedSteam.SteamTypes.UGCQueryHandle,System.UInt32)">
            <summary>
            Retrieve an individual result after receiving the callback for querying UGC
            </summary>
            <param name="handle"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IUGC.ReleaseQueryUGCRequest(ManagedSteam.SteamTypes.UGCQueryHandle)">
            <summary>
            Release the request to free up memory, after retrieving results
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="T:ManagedSteam.IUser">
            <summary>
            Handles user information
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.IsLoggedOn">
            <summary>
            Available in Lite
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetSteamID">
            <summary>
            Available in Lite
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.InitiateGameConnection(System.IntPtr,System.Int32,ManagedSteam.SteamTypes.SteamID,System.UInt32,System.UInt16,System.Boolean)">
            <summary>
            InitiateGameConnection() starts the state machine for authenticating the game client with the game server
            It is the client portion of a three-way handshake between the client, the game server, and the steam servers 
            </summary>
            <param name="authBlob">A pointer to empty memory that will be filled in with the authentication token.</param>
            <param name="maxAuthBlob">The number of bytes of allocated memory in pBlob. Should be at least 2048 bytes.</param>
            <param name="steamIDGameServer">The steamID of the game server, received from the game server by the client.</param>
            <param name="serverIP">The ID of the current game. For games without mods, this is just CGameID( appID ).</param>
            <param name="serverPort">The IP address of the game server.</param>
            <param name="secure">Whether or not the client thinks that the game server is reporting itself as secure (i.e. VAC is running).</param>
            <returns>Returns the number of bytes written to pBlob. If the return is 0, then the buffer passed in was too small, and the call has failed.
            The contents of pBlob should then be sent to the game server, for it to use to complete the authentication process.</returns>
        </member>
        <member name="M:ManagedSteam.IUser.TerminateGameConnection(System.UInt32,System.UInt16)">
            <summary>
            Notify of disconnect, needs to occur when the game client leaves the specified game server, needs to match with the InitiateGameConnection() call.
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.TrackAppUsageEvent(ManagedSteam.SteamTypes.GameID,System.Int32,System.String)">
            <summary>
            Used by only a few games to track usage events.
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetUserDataFolder(System.String@)">
            <summary>
            Get the local storage folder for current Steam account to write application data, e.g. save games, configs etc.
            This will usually be something like "C:\Progam Files\Steam\userdata\Your_SteamID\Your_AppId\local".
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetUserDataFolder">
            <summary>
            Get the local storage folder for current Steam account to write application data, e.g. save games, configs etc.
            This will usually be something like "C:\Progam Files\Steam\userdata\Your_SteamID\Your_AppId\local".
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.StartVoiceRecording">
            <summary>
            Starts voice recording. Once started, use GetVoice() to get the data.
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.StopVoiceRecording">
            <summary>
            Stops voice recording. Because people often release push-to-talk keys early, the system will keep recording for
            a little bit after this function is called. GetVoice() should continue to be called until it returns
            k_eVoiceResultNotRecording.
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetAvailableVoice(System.UInt32@,System.UInt32@,System.UInt32)">
            <summary>
            Determine the amount of captured audio data that is available in bytes.
            This provides both the compressed and uncompressed data. Please note that the uncompressed
            data is not the raw feed from the microphone: data may only be available if audible 
            levels of speech are detected.
            nUncompressedVoiceDesiredSampleRate is necessary to know the number of bytes to return in pcbUncompressed - can be set to 0 if you don't need uncompressed (the usual case)
            If you're upgrading from an older Steamworks API, you'll want to pass in 11025 to nUncompressedVoiceDesiredSampleRate
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetAvailableVoice(System.UInt32)">
            <summary>
            Determine the amount of captured audio data that is available in bytes.
            This provides both the compressed and uncompressed data. Please note that the uncompressed
            data is not the raw feed from the microphone: data may only be available if audible 
            levels of speech are detected.
            nUncompressedVoiceDesiredSampleRate is necessary to know the number of bytes to return in pcbUncompressed - can be set to 0 if you don't need uncompressed (the usual case)
            If you're upgrading from an older Steamworks API, you'll want to pass in 11025 to nUncompressedVoiceDesiredSampleRate
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetVoice(System.Boolean,System.IntPtr,System.UInt32,System.UInt32@,System.Boolean,System.IntPtr,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
            Gets the latest voice data from the microphone. Compressed data is an arbitrary format, and is meant to be handed back to 
            DecompressVoice() for playback later as a binary blob. Uncompressed data is 16-bit, signed integer, 11025Hz PCM format.
            Please note that the uncompressed data is not the raw feed from the microphone: data may only be available if audible 
            levels of speech are detected, and may have passed through denoising filters, etc.
            This function should be called as often as possible once recording has started; once per frame at least.
            nBytesWritten is set to the number of bytes written to pDestBuffer. 
            nUncompressedBytesWritten is set to the number of bytes written to pUncompressedDestBuffer. 
            You must grab both compressed and uncompressed here at the same time, if you want both.
            Matching data that is not read during this call will be thrown away.
            GetAvailableVoice() can be used to determine how much data is actually available.
            If you're upgrading from an older Steamworks API, you'll want to pass in 11025 to nUncompressedVoiceDesiredSampleRate
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetVoice(System.Boolean,System.IntPtr,System.UInt32,System.Boolean,System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            Gets the latest voice data from the microphone. Compressed data is an arbitrary format, and is meant to be handed back to 
            DecompressVoice() for playback later as a binary blob. Uncompressed data is 16-bit, signed integer, 11025Hz PCM format.
            Please note that the uncompressed data is not the raw feed from the microphone: data may only be available if audible 
            levels of speech are detected, and may have passed through denoising filters, etc.
            This function should be called as often as possible once recording has started; once per frame at least.
            nBytesWritten is set to the number of bytes written to pDestBuffer. 
            nUncompressedBytesWritten is set to the number of bytes written to pUncompressedDestBuffer. 
            You must grab both compressed and uncompressed here at the same time, if you want both.
            Matching data that is not read during this call will be thrown away.
            GetAvailableVoice() can be used to determine how much data is actually available.
            If you're upgrading from an older Steamworks API, you'll want to pass in 11025 to nUncompressedVoiceDesiredSampleRate
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.DecompressVoice(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
            Decompresses a chunk of compressed data produced by GetVoice().
            nBytesWritten is set to the number of bytes written to pDestBuffer unless the return value is k_EVoiceResultBufferTooSmall.
            In that case, nBytesWritten is set to the size of the buffer required to decompress the given
            data. The suggested buffer size for the destination buffer is 22 kilobytes.
            The output format of the data is 16-bit signed at the requested samples per second.
            If you're upgrading from an older Steamworks API, you'll want to pass in 11025 to nDesiredSampleRate
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.DecompressVoice(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            Decompresses a chunk of compressed data produced by GetVoice().
            nBytesWritten is set to the number of bytes written to pDestBuffer unless the return value is k_EVoiceResultBufferTooSmall.
            In that case, nBytesWritten is set to the size of the buffer required to decompress the given
            data. The suggested buffer size for the destination buffer is 22 kilobytes.
            The output format of the data is 16-bit signed at the requested samples per second.
            If you're upgrading from an older Steamworks API, you'll want to pass in 11025 to nDesiredSampleRate
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetVoiceOptimalSampleRate">
            <summary>
            This returns the frequency of the voice data as it's stored internally; calling DecompressVoice() with this size will yield the best results
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetAuthSessionTicket(System.IntPtr,System.Int32,System.UInt32@)">
            <summary>
            Retrieve ticket to be sent to the entity who wishes to authenticate you. 
            pcbTicket retrieves the length of the actual ticket.
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetAuthSessionTicket(System.IntPtr,System.Int32)">
            <summary>
            Retrieve ticket to be sent to the entity who wishes to authenticate you. 
            pcbTicket retrieves the length of the actual ticket.
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.BeginAuthSession(System.IntPtr,System.Int32,ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Authenticate ticket from entity steamID to be sure it is valid and isnt reused
            Registers for callbacks if the entity goes offline or cancels the ticket ( see ValidateAuthTicketResponse_t callback and EAuthSessionResponse )
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.EndAuthSession(ManagedSteam.SteamTypes.SteamID)">
            <summary>
            Stop tracking started by BeginAuthSession - called when no longer playing game with this entity
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.CancelAuthTicket(System.UInt32)">
            <summary>
            Cancel auth ticket from GetAuthSessionTicket, called when no longer playing game with the entity you gave the ticket to
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.UserHasLicenseForApp(ManagedSteam.SteamTypes.SteamID,ManagedSteam.SteamTypes.AppID)">
            <summary>
            After receiving a user's authentication data, and passing it to BeginAuthSession, use this function
            to determine if the user owns downloadable content specified by the provided AppID.
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.IsBehindNAT">
            <summary>
            returns true if this users looks like they are behind a NAT device. Only valid once the user has connected to steam 
            (i.e a SteamServersConnected_t has been issued) and may not catch all forms of NAT.
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.AdvertiseGame(ManagedSteam.SteamTypes.SteamID,System.UInt32,System.UInt16)">
            <summary>
            Set data to be replicated to friends so that they can join your game
            </summary>
            <param name="steamIDGameServer">the steamID of the game server, received from the game server by the client</param>
            <param name="serverIP">the IP address of the game server</param>
            <param name="serverPort">the port of the game server</param>
        </member>
        <member name="M:ManagedSteam.IUser.RequestEncryptedAppTicket(System.IntPtr,System.Int32)">
            <summary>
            Requests a ticket encrypted with an app specific shared key
            pDataToInclude, cbDataToInclude will be encrypted into the ticket
            ( This is asynchronous, you must wait for the ticket to be completed by the server )
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetEncryptedAppTicket(System.IntPtr,System.Int32,System.UInt32@)">
            <summary>
            Retrieve a finished ticket
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetEncryptedAppTicket(System.IntPtr,System.Int32)">
            <summary>
            Retrieve a finished ticket
            </summary>
        </member>
        <member name="M:ManagedSteam.IUser.GetGameBadgeLevel(System.Int32,System.Boolean)">
            <summary>
            Trading Card badges data access
            </summary>
            <param name="nSeries">If you only have one set of cards, the series will be 1</param>
            <param name="bFoil">The user has can have two different badges for a series; the regular (max level 5) and the foil (max level 1)</param>
        </member>
        <member name="M:ManagedSteam.IUser.GetPlayerSteamLevel">
            <summary>
            Gets the Steam Level of the user, as shown on their profile
            </summary>
        </member>
        <member name="T:ManagedSteam.IUtils">
            <summary>
            Steam utility functions
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetSecondsSinceAppActive">
            <summary>
            <returns>The number of seconds the app have been running</returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetSecondsSinceComputerActive">
            <summary>
            <returns>The number of seconds the computer have been running</returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetConnectedUniverse">
            <summary>
            The universe the client is connected to
            <returns>Enum that lists the different universes the client can be connected to.</returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetServerRealTime">
            <summary>
            Steam server time - in PST
            <returns>Number of seconds since Januari 1, 1970 (i.e. unix time)</returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetIPCountry">
            <summary>
            Returns 2 digit ISO 3166-1-alpha-2 format country code this client is running in (as looked up via an IP-to-location database)
            eg. "US" or "UK"
            <returns></returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetImageSize(ManagedSteam.SteamTypes.ImageHandle,System.UInt32@,System.UInt32@)">
            <summary>
            Gets dimensions of an image from a steam image handle
            <returns>True if the image exists</returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetImageRGBA(ManagedSteam.SteamTypes.ImageHandle,System.IntPtr,System.Int32)">
            <summary>
            Fills the supplied buffer with the image data in RGBA format
            The destination buffer size should be 4 * height * width * sizeof(byte)
            <returns>True if the image exists and the buffer was successfully filled out</returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetCSERIPPort(System.UInt32@,System.UInt16@)">
            <summary>
            <returns></returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetCSERIPPort">
            <summary>
            <returns></returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetCurrentBatteryPower">
            <summary>
            The amount of battery power left in the current system in % [0..100], 255 for beeing on AC power.
            <returns>Integer representing amount of power left</returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.SetOverlayNotificationPosition(ManagedSteam.SteamTypes.NotificationPosition)">
            <summary>
            Sets the position where the overlay instance for the currently calling game should show notifications. 
            This position is per-game and if this function is called from outside of a game context it will do nothing.
            <returns></returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.IsAPICallCompleted(ManagedSteam.SteamTypes.SteamAPICall,System.Boolean@)">
            <summary>
            <returns></returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetAPICallResult``1(ManagedSteam.SteamTypes.SteamAPICall,``0@,System.Boolean@)">
            <summary>
            <returns></returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.RunFrame">
            <summary>
            This needs to be called every frame to process matchmaking results.
            Redundant if you're already calling SteamAPI_RunCallbacks()
            <returns></returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetIPCCallCount">
            <summary>
            Returns the number of IPC calls made since the last time this function was called.
            Used for perf debugging so you can understand how many IPC calls your game makes per frame.
            Every IPC call is at minimum a thread context switch if not a process one so you want to rate
            control how often you do them.
            <returns></returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.IsOverlayEnabled">
            <summary>
            The overlay process could take a few seconds to start and hook the game process, 
            so this function will initially return false while the overlay is loading.
            <returns> True if the overlay is running and the user can access it</returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.OverlayNeedsPresent">
            <summary>
            Normally this call is unneeded if your game has a constantly running frame loop that calls the 
            D3D Present API, or OGL SwapBuffers API every frame.
            
            However, if you have a game that only refreshes the screen on an event driven basis then that can break 
            the overlay, as it uses your Present/SwapBuffers calls to drive it's internal frame loop and it may also
            need to Present() to the screen any time an even needing a notification happens or when the overlay is
            brought up over the game by a user.  You can use this API to ask the overlay if it currently need a present
            in that case, and then you can check for this periodically (roughly 33hz is desirable) and make sure you
            refresh the screen with Present or SwapBuffers to allow the overlay to do it's work.
            <returns></returns>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.ShowGamepadTextInput(ManagedSteam.SteamTypes.GamepadTextInputMode,ManagedSteam.SteamTypes.GamepadTextInputLineMode,System.String,System.UInt32)">
            <summary>
            <return></return>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetEnteredGamepadTextLength">
            <summary>
            <return></return>
            </summary>
        </member>
        <member name="M:ManagedSteam.IUtils.GetEnteredGamepadTextInput(System.String@)">
            <summary>
            
            </summary>
            <return></return>
        </member>
        <member name="M:ManagedSteam.IUtils.GetEnteredGamepadTextInput">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.IUtils.IsSteamRunningInVR">
            <summary>
            Is Steam itself running in VR.
            </summary>
            <returns></returns>
        </member>
        <member name="E:ManagedSteam.IUtils.LowBatteryPower">
            <summary>
            Registred event fires when device have less than 10 minutes batterypower remaining, then once every minute
            </summary>
        </member>
        <member name="E:ManagedSteam.IUtils.SteamShutdown">
            <summary>
            Registred event fires when steam wants to shut down, for example when the user rightclick on the steam icon and click Shutdown
            </summary>
        </member>
        <member name="E:ManagedSteam.IUtils.GamepadTextInputDismissed">
            <summary>
            Registred event fires when the Big picture text input have shut down, this can either be cancled or submitted, result in GamepadTextInputDismissed struct
            </summary>
        </member>
        <member name="T:ManagedSteam.StringMap">
            <summary>
            A class that contains all the strings that are presented to the user.
            </summary>
        </member>
        <member name="M:ManagedSteam.StringMap.GetString(ManagedSteam.ErrorCodes,System.Object[])">
            <summary>
            Replaces any % with a value from the variables list. Does not throw any exception if 
            the number of variables does not match.
            </summary>
            <param name="id"></param>
            <param name="variables"></param>
            <returns></returns>
        </member>
        <member name="T:ManagedSteam.MatchmakingPingResponse">
            <summary>
            Managed version of the \a ISteamMatchmakingServerListResponse interface.
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingPingResponse.#ctor">
            <summary>
            Creates a managed and native object that cooperate to enable matchmaking callbacks from 
            MatchmakingServers.
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingPingResponse.ServerRespondedCallback(System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            Callback that is called directly from native code
            </summary>
            <param name="instanceId"></param>
            <param name="server"></param>
            <param name="serverSize"></param>
        </member>
        <member name="M:ManagedSteam.MatchmakingPingResponse.LibraryShuttingDown">
            <summary>
            Called from outside when the managed part of the library is shutting down
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingPingResponse.ServerResponded(ManagedSteam.SteamTypes.GameServerItem)">
            <summary>
            Server has responded successfully and has updated data
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingPingResponse.ServerFailedToRespond">
            <summary>
            Server failed to respond to the ping request
            </summary>
        </member>
        <member name="P:ManagedSteam.MatchmakingPingResponse.ObjectId">
            <summary>
            The id of this object. This is actually the address of the native object
            </summary>
        </member>
        <member name="P:ManagedSteam.MatchmakingPingResponse.Disposed">
            <summary>
            When true, the object have been disposed and will no longer receive callbacks.
            </summary>
        </member>
        <member name="T:ManagedSteam.MatchmakingPlayersResponse">
            <summary>
            Managed version of the \a ISteamMatchmakingServerListResponse interface.
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingPlayersResponse.#ctor">
            <summary>
            Creates a managed and native object that cooperate to enable matchmaking callbacks from 
            MatchmakingServers.
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingPlayersResponse.AddPlayerToListCallback(System.UInt32,System.IntPtr,System.Int32,System.Single)">
            <summary>
            Callback that is called directly from native code
            </summary>
            <param name="instanceId"></param>
            <param name="name"></param>
            <param name="score"></param>
            <param name="timePlayed"></param>
        </member>
        <member name="M:ManagedSteam.MatchmakingPlayersResponse.LibraryShuttingDown">
            <summary>
            Called from outside when the managed part of the library is shutting down
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingPlayersResponse.AddPlayerToList(System.String,System.Int32,System.Single)">
            <summary>
            Got data on a new player on the server -- you'll get this callback once per player
            on the server which you have requested player data on.
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingPlayersResponse.PlayersFailedToRespond">
            <summary>
            The server failed to respond to the request for player details
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingPlayersResponse.PlayersRefreshComplete">
            <summary>
            The server has finished responding to the player details request 
            (ie, you won't get anymore AddPlayerToList callbacks)
            </summary>
        </member>
        <member name="P:ManagedSteam.MatchmakingPlayersResponse.ObjectId">
            <summary>
            The id of this object. This is actually the address of the native object
            </summary>
        </member>
        <member name="P:ManagedSteam.MatchmakingPlayersResponse.Disposed">
            <summary>
            When true, the object have been disposed and will no longer receive callbacks.
            </summary>
        </member>
        <member name="T:ManagedSteam.MatchmakingRulesResponse">
            <summary>
            Managed version of the \a ISteamMatchmakingServerListResponse interface.
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingRulesResponse.#ctor">
            <summary>
            Creates a managed and native object that cooperate to enable matchmaking callbacks from 
            MatchmakingServers.
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingRulesResponse.RulesRespondedCallback(System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            Callback that is called directly from native code
            </summary>
            <param name="instanceId"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:ManagedSteam.MatchmakingRulesResponse.LibraryShuttingDown">
            <summary>
            Called from outside when the managed part of the library is shutting down
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingRulesResponse.RulesResponded(System.String,System.String)">
            <summary>
            Got data on a rule on the server -- you'll get one of these per rule defined on
            the server you are querying
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingRulesResponse.RulesFailedToRespond">
            <summary>
            The server failed to respond to the request for rule details
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingRulesResponse.RulesRefreshComplete">
            <summary>
            The server has finished responding to the rule details request 
            (ie, you won't get anymore RulesResponded callbacks)
            </summary>
        </member>
        <member name="P:ManagedSteam.MatchmakingRulesResponse.ObjectId">
            <summary>
            The id of this object. This is actually the address of the native object
            </summary>
        </member>
        <member name="P:ManagedSteam.MatchmakingRulesResponse.Disposed">
            <summary>
            When true, the object have been disposed and will no longer receive callbacks.
            </summary>
        </member>
        <member name="T:ManagedSteam.MatchmakingServerListResponse">
            <summary>
            Managed version of the \a ISteamMatchmakingServerListResponse interface.
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingServerListResponse.#ctor">
            <summary>
            Creates a managed and native object that cooperate to enable matchmaking callbacks from 
            MatchmakingServers.
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingServerListResponse.ServerRespondedCallback(System.UInt32,System.UInt32,System.Int32)">
            <summary>
            Callback that is called directly from native code
            </summary>
            <param name="instanceId"></param>
            <param name="request"></param>
            <param name="server"></param>
        </member>
        <member name="M:ManagedSteam.MatchmakingServerListResponse.LibraryShuttingDown">
            <summary>
            Called from outside when the managed part of the library is shutting down
            </summary>
        </member>
        <member name="M:ManagedSteam.MatchmakingServerListResponse.ServerResponded(ManagedSteam.SteamTypes.ServerListRequestHandle,System.Int32)">
            <summary>
            Server has responded ok with updated data
            </summary>
            <param name="request"></param>
            <param name="server"></param>
        </member>
        <member name="M:ManagedSteam.MatchmakingServerListResponse.ServerFailedToRespond(ManagedSteam.SteamTypes.ServerListRequestHandle,System.Int32)">
            <summary>
            Server has failed to respond
            </summary>
            <param name="request"></param>
            <param name="server"></param>
        </member>
        <member name="M:ManagedSteam.MatchmakingServerListResponse.RefreshComplete(ManagedSteam.SteamTypes.ServerListRequestHandle,ManagedSteam.SteamTypes.MatchMakingServerResponse)">
            <summary>
            A list refresh you had initiated is now 100% completed
            </summary>
            <param name="request"></param>
            <param name="response"></param>
        </member>
        <member name="P:ManagedSteam.MatchmakingServerListResponse.ObjectId">
            <summary>
            The id of this object. This is actually the address of the native object
            </summary>
        </member>
        <member name="P:ManagedSteam.MatchmakingServerListResponse.Disposed">
            <summary>
            When true, the object have been disposed and will no longer receive callbacks.
            </summary>
        </member>
        <member name="T:ManagedSteam.ServicesGameServer">
            <summary>
            The main class for game servers
            This is the primary interface point between .NET code and the native C++ code.
            Use Initialize() to start the API.
            </summary>
        </member>
        <member name="M:ManagedSteam.ServicesGameServer.Initialize(System.UInt32,System.UInt16,System.UInt16,System.UInt16,ManagedSteam.SteamTypes.ServerMode,System.String)">
            <summary>
            Initializes the native dll and the managed wrapper. Use the returned class to
            communicate with the steam API. Can only be used once.
            </summary>
            <exception cref="T:ManagedSteam.Exceptions.AlreadyLoadedException"></exception>
            <exception cref="T:ManagedSteam.Exceptions.SteamInitializeFailedException"></exception>
            <exception cref="T:ManagedSteam.Exceptions.SteamInterfaceInitializeFailedException"></exception>
            <exception cref="T:System.InvalidOperationException">One instance of the Steam class already exists.</exception>
            <returns>The instance of the Steam class to be used for all communication with the Steamworks API.</returns>
        </member>
        <member name="M:ManagedSteam.ServicesGameServer.Shutdown">
            <summary>
            Call this right before your game shuts down. This performs cleanup of managed and native resources.
            </summary>
            <remarks>No parts of the API will be usable after this.</remarks>
        </member>
        <member name="M:ManagedSteam.ServicesGameServer.Update">
            <summary>
            This method dispatches all events. It needs to be run at regular intervals (like every frame).
            </summary>
        </member>
        <member name="M:ManagedSteam.ServicesGameServer.ReleaseManagedResources">
            <summary>
            This will release all the managed resources. The native dll is still loaded and usable.
            Just call Initialize to be able to communicate with steam again.
            This method is only intended to be used if the API is used in Unity's editor during
            development.
            </summary>
        </member>
        <member name="M:ManagedSteam.ServicesGameServer.CheckIfUsable">
            <summary>
            This method does some general checks to see if the current instance can communicate with the native dll.
            </summary>
        </member>
        <member name="P:ManagedSteam.ServicesGameServer.Instance">
            <summary>
            The active instance that can communicate with the Steamworks API.
            </summary>
        </member>
        <member name="P:ManagedSteam.ServicesGameServer.IsAvailable">
            <summary>
            Returns true if communication with the steam API is possible
            </summary>
        </member>
        <member name="E:ManagedSteam.ServicesGameServer.ExceptionThrown">
            <summary>
            This event is raised if any exceptions are thrown directly or indirectly from native code.
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.AuthSessionResponse">
            <summary>
            Managed version of the \a EAuthSessionResponse
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.BeginAuthSessionResult">
            <summary>
            Managed version of the \a EBeginAuthSessionResult enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.BeginAuthSessionResult.OK">
            <summary>
            Ticket is valid for this game and this steamID.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.BeginAuthSessionResult.InvalidTicket">
            <summary>
            Ticket is not valid.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.BeginAuthSessionResult.DuplicateRequest">
            <summary>
            A ticket has already been submitted for this steamID
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.BeginAuthSessionResult.InvalidVersion">
            <summary>
            Ticket is from an incompatible interface version
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.BeginAuthSessionResult.GameMismatch">
            <summary>
            Ticket is not for this game
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.BeginAuthSessionResult.ExpiredTicket">
            <summary>
            Ticket has expired
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.ChatEntryType">
            <summary>
            Managed version of the \a EChatEntryType enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.ChatMemberStateChange">
            <summary>
            Managed version of the \steamref EChatMemberStateChange enum
            
            Purpose: Used in ChatInfo messages - fields specific to a chat member
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatMemberStateChange.Entered">
            <summary>
            This user has joined or is joining the chat room
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatMemberStateChange.Left">
            <summary>
            This user has left or is leaving the chat room
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatMemberStateChange.Disconnected">
            <summary>
            User disconnected without leaving the chat first
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatMemberStateChange.Kicked">
            <summary>
            User kicked
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatMemberStateChange.Banned">
            <summary>
            User kicked and banned
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.ChatRoomEnterResponse">
            <summary>
            Managed version of the \a EChatRoomEnterRepsonse enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.Success">
            <summary>
            Success
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.DoesntExist">
            <summary>
            Chat doesn't exist (probably closed)
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.NotAllowed">
            <summary>
            General Denied - You don't have the permissions needed to join the chat
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.Full">
            <summary>
            Chat room has reached its maximum size
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.Error">
            <summary>
            Unexpected Error
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.Banned">
            <summary>
            You are banned from this chat room and may not join
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.Limited">
            <summary>
            Joining this chat is not allowed because you are a limited user (no value on account)
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.ClanDisabled">
            <summary>
            Attempt to join a clan chat when the clan is locked or disabled
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.CommunityBan">
            <summary>
            Attempt to join a chat when the user has a community lock on their account
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.MemberBlockedYou">
            <summary>
            Join failed - some member in the chat has blocked you from joining
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.YouBlockedMember">
            <summary>
            Join failed - you have blocked some member already in the chat
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.NoRankingDataLobby">
            <summary>
            There is no ranking data available for the lobby 
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.NoRankingDataUser">
            <summary>
            There is no ranking data available for the user
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ChatRoomEnterResponse.RankOutOfRange">
            <summary>
            The user is out of the allowable ranking range
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.ECheckFileSignature">
            <summary>
            Managed version of the \a ECheckFileSignature.
            
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.DenyReason">
            <summary>
            Managed version of the \steamref EDenyReason enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.DistortionCoordinates">
            <summary>
            Used to return the post-distortion UVs for each color channel
            UVs range from 0 to 1 with 0,0 in the upper left corner of the 
            source render target. The 0,0 to 1,1 range covers a single eye.
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.GameServerItem">
            <summary>
            Managed version of the \a gameserveritem_t class
            </summary>
        </member>
        <member name="M:ManagedSteam.SteamTypes.GameServerItem.GetName">
            <summary>
            The server name. Will return the same value as the ServerName property
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedSteam.SteamTypes.GameServerItem.SetName(System.String)">
            <summary>
            Changes the server name. The same as assigning to the ServerName property
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.ServerNetworkAddress">
            <summary>
            IP/Query Port/Connection Port for this server
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.Ping">
            <summary>
            current ping time in milliseconds
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.HadSuccessfulResponse">
            <summary>
            server has responded successfully in the past
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.DoNotRefresh">
            <summary>
            server is marked as not responding and should no longer be refreshed
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.GameDir">
            <summary>
            current game directory
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.Map">
            <summary>
            current map
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.GameDescription">
            <summary>
            game description
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.AppID">
            <summary>
            Steam App ID of this server
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.Players">
            <summary>
            total number of players currently on the server.  INCLUDES BOTS!!
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.MaxPlayers">
            <summary>
            Maximum players that can join this server
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.BotPlayers">
            <summary>
            Number of bots (i.e simulated players) on this server
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.Password">
            <summary>
            true if this server needs a password to join
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.Secure">
            <summary>
            Is this server protected by VAC
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.TimeLastPlayed">
            <summary>
            time (in unix time) when this server was last played on (for favorite/history servers)
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.ServerVersion">
            <summary>
            server version as reported to Steam
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.ServerName">
            <summary>
            Game server name
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.GameTags">
            <summary>
            the tags this server exposes
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.GameServerItem.SteamID">
            <summary>
            steamID of the game server - invalid if it's doesn't have one (old server, or not connected to Steam)
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.GraphicsAPIConvention.DirectX">
            <summary>
            Normalized Z goes from 0 at the viewer to 1 at the far clip plane
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.GraphicsAPIConvention.OpenGL">
            <summary>
            Normalized Z goes from 1 at the viewer to -1 at the far clip plane
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.HmdMatrix34">
            <summary>
            right-handed system
            +y is up
            +x is to the right
            -z is going away from you
            Distance unit is  meters
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.HmdMatrix34.m">
            <summary>
            right-handed system
            +y is up
            +x is to the right
            -z is going away from you
            Distance unit is  meters
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.HTTPMethod">
            <summary>
            Managed version of EHTTPMethod enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.HTTPMethod.Invalid">
            <summary></summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.HTTPMethod.GET">
            <summary></summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.HTTPMethod.HEAD">
            <summary></summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.HTTPMethod.POST">
            <summary></summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.HTTPMethod.PUT">
            <summary></summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.HTTPMethod.DELETE">
            <summary></summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.HTTPMethod.OPTIONS">
            <summary></summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.LobbyComparison">
            <summary>
            Managed version of the \a ELobbyComparison enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.LobbyDistanceFilter">
            <summary>
            Managed version of the \a ELobbyDistanceFilter enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LobbyDistanceFilter.Close">
            <summary>
            only lobbies in the same immediate region will be returned
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LobbyDistanceFilter.Default">
            <summary>
            only lobbies in the same region or near by regions
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LobbyDistanceFilter.Far">
            <summary>
            for games that don't have many latency requirements, will return lobbies about half-way around the globe
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LobbyDistanceFilter.Worldwide">
            <summary>
            no filtering, will match lobbies as far as India to NY (not recommended, expect multiple seconds of latency between the clients)
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.LobbyType">
            <summary>
            Managed version of the \a ELobbyType enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LobbyType.Private">
            <summary>
            only way to join the lobby is to invite to someone else
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LobbyType.FriendsOnly">
            <summary>
            shows for friends or invitees, but not in lobby list
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LobbyType.Public">
            <summary>
            visible for friends and in lobby list
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LobbyType.Invisible">
            <summary>
            returned by search, but not visible to other friends 
            useful if you want a user in two lobbies, for example matching groups together
            a user can be in only one regular lobby, and up to two invisible lobbies
            </summary>
        </member>
        <member name="T:ManagedSteam.ErrorCodes">
            <summary>
            Internal error codes
            </summary>
        </member>
        <member name="T:ManagedSteam.OverlayDialog">
            <summary>
            The different overlay types that exist
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.AppID.AsUInt64">
            <summary>
            Returns the AppID as a 64-bit unsigned integer.
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.AppID.AsUInt32">
            <summary>
            Returns the AppID as a 32-bit unsigned integer.
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.FriendFlags">
            <summary>
            Managed version of the \a EFriendFlags enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.FriendFlags.Immediate">
            <summary>
            "regular" friend
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.FriendGameInfo">
            <summary>
            friend game played information
            
            Wrapper for the \a FriendGameInfo_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.FriendRelationship">
            <summary>
            Managed version of the \a EFriendRelationship enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.LeaderboardDataRequest">
            <summary>
            Managed version of the \a ELeaderboardDataRequest enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.LeaderboardDisplayType">
            <summary>
            Managed version of the \a ELeaderboardDisplayType enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LeaderboardDisplayType.Numeric">
            <summary>
            Simple numerical score
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LeaderboardDisplayType.TimeSeconds">
            <summary>
            the score represents a time, in seconds
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LeaderboardDisplayType.TimeMilliSeconds">
            <summary>
            the score represents a time, in milliseconds
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.LeaderboardEntry">
            <summary>
            Wrapper for the \a LeaderboardEntry_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.LeaderboardSortMethod">
            <summary>
            Managed version of the \a ELeaderboardSortMethod enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LeaderboardSortMethod.Ascending">
            <summary>
            top-score is lowest number
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.LeaderboardSortMethod.Descending">
            <summary>
            top-score is highest number
            </summary>
        </member>
        <member name="T:ManagedSteam.LoadStatus">
            <summary>
            The load status of the native dll
            </summary>
        </member>
        <member name="T:ManagedSteam.ResultID">
            <summary>
            Id for async result callbacks.
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.LeaderboardUploadScoreMethod">
            <summary>
            Managed version of the \a ELeaderboardUploadScoreMethod enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.MatchMakingKeyValuePair">
            <summary>
            Managed version of the \a MatchMakingKeyValuePair_t struct
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.MatchMakingServerResponse">
            <summary>
            Managed version of the \a EMatchMakingServerResponse enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.MatchMakingServerResponse.NoServersListedOnMasterServer">
            <summary>
            for the Internet query type, returned in response callback if no servers of this type match
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.NetSocketConnectionType">
            <summary>
            Managed version of the \a ENetSocketConnectionType enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.NotificationPosition">
            <summary>
            Possible positiont to tell the overlay to show notifications in
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.P2PSend">
            <summary>
            SendP2PPacket() send types
            Typically k_EP2PSendUnreliable is what you want for UDP-like packets, k_EP2PSendReliable 
            for TCP-like packets
            
            Managed version of the \a EP2PSend enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.P2PSend.Unreliable">
            <summary>
            Basic UDP send. Packets can't be bigger than 1200 bytes (your typical MTU size). Can be lost, or arrive out of order (rare).
            The sending API does have some knowledge of the underlying connection, so if there is no NAT-traversal accomplished or
            there is a recognized adjustment happening on the connection, the packet will be batched until the connection is open again.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.P2PSend.UnreliableNoDelay">
            <summary>
            As above, but if the underlying p2p connection isn't yet established the packet will just be thrown away. Using this on the first
            packet sent to a remote host almost guarantees the packet will be dropped.
            This is only really useful for kinds of data that should never buffer up, i.e. voice payload packets
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.P2PSend.Reliable">
            <summary>
            Reliable message send. Can send up to 1MB of data in a single message. 
            Does fragmentation/re-assembly of messages under the hood, as well as a sliding window for efficient sends of large chunks of data. 
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.P2PSend.ReliableWithBuffering">
            <summary>
            As above, but applies the Nagle algorithm to the send - sends will accumulate 
            until the current MTU size (typically ~1200 bytes, but can change) or ~200ms has passed (Nagle algorithm). 
            Useful if you want to send a set of smaller messages but have the coalesced into a single packet
            Since the reliable stream is all ordered, you can do several small message sends with k_EP2PSendReliableWithBuffering and then
            do a normal k_EP2PSendReliable to force all the buffered data to be sent.
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.P2PSessionError">
            <summary>
            list of possible errors returned by SendP2PPacket() API
            these will be posted in the P2PSessionConnectFail_t callback
            
            Managed version of the \a EP2PSessionError enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.P2PSessionError.NotRunningApp">
            <summary>
            target is not running the same game
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.P2PSessionError.NoRightsToApp">
            <summary>
            local user doesn't own the app that is running
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.P2PSessionError.DestinationNotLoggedIn">
            <summary>
            target user isn't connected to Steam
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.P2PSessionError.Timeout">
            <summary>
            target isn't responding, perhaps not calling AcceptP2PSessionWithUser().
            corporate firewalls can also block this (NAT traversal is not firewall traversal)
            make sure that UDP ports 3478, 4379, and 4380 are open in an outbound direction
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.P2PSessionState.ConnectionActive">
            <summary>
            true if we've got an active open connection
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.P2PSessionState.Connecting">
            <summary>
            true if we're currently trying to establish a connection
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.P2PSessionState.P2PSessionError">
            <summary>
            last error recorded 
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.P2PSessionState.UsingRelay">
            <summary>
            true if it's going through a relay server (TURN)
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.P2PSessionState.RemoteIP">
            <summary>
            potential IP:Port of remote host. Could be TURN server. 
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.P2PSessionState.RemotePort">
            <summary>
            Only exists for compatibility with older authentication api's
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.PersonaChange">
            <summary>
            used in PersonaStateChange_t::m_nChangeFlags to describe what's changed about a user.
            These flags describe what the client has learned has changed recently, so on startup 
            you'll see a name, avatar and relationship change for every friend
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.PersonaState">
            <summary>
            Managed version of the \a EPersonaState enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.PersonaState.Offline">
            <summary>
            friend is not currently logged on
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.PersonaState.Online">
            <summary>
            friend is logged on
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.PersonaState.Busy">
            <summary>
            user is on, but busy
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.PersonaState.Away">
            <summary>
            auto-away feature
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.PersonaState.Snooze">
            <summary>
            auto-away for a long time
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.PersonaState.LookingToTrade">
            <summary>
            Online, trading
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.PersonaState.LookingToPlay">
            <summary>
            Online, wanting to play
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.RemoteStoragePlatform">
            <summary>
            Managed version of the \a ERemoteStoragePlatform enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.RemoteStoragePublishedFileVisibility">
            <summary>
            Managed version of the \a ERemoteStoragePublishedFileVisibility enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.ResolveConflict">
            <summary>
            Managed version of the \a EResolveConflict enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ResolveConflict.KeepClient">
            <summary>
            The local version of each file will be used to overwrite the server version
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.ResolveConflict.KeepServer">
            <summary>
            The server version of each file will be used to overwrite the local version
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.Result">
            <summary>
            Managed version of the \a EResult enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.OK">
            <summary>
            success
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Fail">
            <summary>
            generic failure 
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.NoConnection">
            <summary>
            no/failed network connection
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.InvalidPassword">
            <summary>
            password/ticket is invalid
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.LoggedInElsewhere">
            <summary>
            same user logged in elsewhere
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.InvalidProtocolVer">
            <summary>
            protocol version is incorrect
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.InvalidParam">
            <summary>
            a parameter is incorrect
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.FileNotFound">
            <summary>
            file was not found
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Busy">
            <summary>
            called method busy - action not taken
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.InvalidState">
            <summary>
            called object was in an invalid state
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.InvalidName">
            <summary>
            name is invalid
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.InvalidEmail">
            <summary>
            email is invalid
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.DuplicateName">
            <summary>
            name is not unique
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AccessDenied">
            <summary>
            access is denied
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Timeout">
            <summary>
            operation timed out
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Banned">
            <summary>
            VAC2 banned
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AccountNotFound">
            <summary>
            account not found
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.InvalidSteamID">
            <summary>
            steamID is invalid
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.ServiceUnavailable">
            <summary>
            The requested service is currently unavailable
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.NotLoggedOn">
            <summary>
            The user is not logged on
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Pending">
            <summary>
            Request is pending (may be in process, or waiting on third party)
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.EncryptionFailure">
            <summary>
            Encryption or Decryption failed
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.InsufficientPrivilege">
            <summary>
            Insufficient privilege
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.LimitExceeded">
            <summary>
            Too much of a good thing
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Revoked">
            <summary>
            Access has been revoked (used for revoked guest passes)
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Expired">
            <summary>
            License/Guest pass the user is trying to access is expired
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AlreadyRedeemed">
            <summary>
            Guest pass has already been redeemed by account, cannot be acked again
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.DuplicateRequest">
            <summary>
            The request is a duplicate and the action has already occurred in the past, ignored this time
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AlreadyOwned">
            <summary>
            All the games in this guest pass redemption request are already owned by the user
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.IPNotFound">
            <summary>
            IP address not found
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.PersistFailed">
            <summary>
            failed to write change to the data store
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.LockingFailed">
            <summary>
            failed to acquire access lock for this operation
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.ShoppingCartNotFound">
            <summary>
            failed to find the shopping cart requested
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Blocked">
            <summary>
            a user didn't allow it
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Ignored">
            <summary>
            target is ignoring sender
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.NoMatch">
            <summary>
            nothing matching the request found
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.ServiceReadOnly">
            <summary>
            this service is not accepting content changes right now
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AccountNotFeatured">
            <summary>
            account doesn't have value, so this feature isn't available
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AdministratorOK">
            <summary>
            allowed to take this action, but only because requester is admin
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.ContentVersion">
            <summary>
            A Version mismatch in content transmitted within the Steam protocol.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.TryAnotherCM">
            <summary>
            The current CM can't service the user making a request, user should try another.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.PasswordRequiredToKickSession">
            <summary>
            You are already logged in elsewhere, this cached credential login has failed.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AlreadyLoggedInElsewhere">
            <summary>
            You are already logged in elsewhere, you must wait
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Suspended">
            <summary>
            Long running operation (content download) suspended/paused
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Cancelled">
            <summary>
            Operation canceled (typically by user: content download)
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.DataCorruption">
            <summary>
            Operation canceled because data is ill formed or unrecoverable
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.DiskFull">
            <summary>
            Operation canceled - not enough disk space.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.RemoteCallFailed">
            <summary>
            an remote call or IPC call failed
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.PasswordUnset">
            <summary>
            Password could not be verified as it's unset server side
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.ExternalAccountUnlinked">
            <summary>
            External account (PSN, Facebook...) is not linked to a Steam account
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.PSNTicketInvalid">
            <summary>
            PSN ticket was invalid
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.ExternalAccountAlreadyLinked">
            <summary>
            External account (PSN, Facebook...) is already linked to some other account, must explicitly request to replace/delete the link first
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.RemoteFileConflict">
            <summary>
            The sync cannot resume due to a conflict between the local and remote files
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.IllegalPassword">
            <summary>
            The requested new password is not legal
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.SameAsPreviousValue">
            <summary>
            new value is the same as the old one ( secret question and answer )
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AccountLogonDenied">
            <summary>
            account login denied due to 2nd factor authentication failure
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.CannotUseOldPassword">
            <summary>
            The requested new password is not legal
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.InvalidLoginAuthCode">
            <summary>
            account login denied due to auth code invalid
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AccountLogonDeniedNoMail">
            <summary>
            account login denied due to 2nd factor auth failure - and no mail has been sent
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.ParentalControlRestricted">
            <summary>
            operation failed due to parental control restrictions for current user
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.FacebookQueryError">
            <summary>
            Facebook query returned an error
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.ExpiredLoginAuthCode">
            <summary>
            account login denied due to auth code expired
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.IPLoginRestrictionFailed">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AccountLockedDown">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.AccountLogonDeniedVerifiedEmailRequired">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.NoMatchingURL">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.BadResponse">
            <summary>
            parse failure, missing field, etc.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.RequirePasswordReEntry">
            <summary>
            The user cannot complete the action until they re-enter their password
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.ValueOutOfRange">
            <summary>
            the value entered is outside the acceptable range
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.UnexpectedError">
            <summary>
            something happened that we didn't expect to ever happen
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.Disabled">
            <summary>
            The requested service has been configured to be unavailable
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.InvalidCEGSubmission">
            <summary>
            The set of files submitted to the CEG server are not valid!
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.RestrictedDevice">
            <summary>
            The device being used is not allowed to perform this action
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.RegionLocked">
            <summary>
            The action could not be complete because it is region restricted
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Result.RateLimitExceeded">
            <summary>
            Temporary rate limit exceeded, try again later, different from LimitExceeded which may be permanent
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.ServerListRequestHandle">
            <summary>
            Managed version of the \a HServerListRequest type
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.ServerMode">
            <summary>
            Managed version of the \a EServerMode Enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.ServerNetworkAddress">
            <summary>
            Managed version of the \a servernetadr_t class
            </summary>
        </member>
        <member name="M:ManagedSteam.SteamTypes.ServerNetworkAddress.#ctor(System.UInt32,System.UInt16,System.UInt16)">
            <summary>
            If an instance is created with this constructor, there is no need to call Init.
            </summary>
            <param name="ip"></param>
            <param name="queryPort"></param>
            <param name="connectionPort"></param>
        </member>
        <member name="M:ManagedSteam.SteamTypes.ServerNetworkAddress.GetConnectionAddressString">
            <summary>
            This gets the 'a.b.c.d:port' string with the connection port (instead of the query port).
            </summary>
            <returns></returns>
        </member>
        <member name="P:ManagedSteam.SteamTypes.ServerNetworkAddress.ConnectionPort">
            <summary>
            (in HOST byte order)
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.SNetSocketState">
            <summary>
            Managed version of the \a ESNetSocketState enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SNetSocketState.Connected">
            <summary>
            communication is valid
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SNetSocketState.Initiated">
            <summary>
            states while establishing a connection.
            
            the connection state machine has started
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SNetSocketState.LocalCandidatesFound">
            <summary>
            p2p connections
            
            we've found our local IP info
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SNetSocketState.ReceivedRemoteCandidates">
            <summary>
            p2p connections
            
            we've received information from the remote machine, via the Steam back-end, about their IP info
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SNetSocketState.ChallengeHandshake">
            <summary>
            direct connections
            
            we've received a challenge packet from the server
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SNetSocketState.Disconnecting">
            <summary>
            failure states
            
            the API shut it down, and we're in the process of telling the other end	
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SNetSocketState.LocalDisconnect">
            <summary>
            failure states
            
            the API shut it down, and we've completed shutdown
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SNetSocketState.TimeoutDuringConnect">
            <summary>
            failure states
            
            we timed out while trying to creating the connection
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SNetSocketState.RemoteEndDisconnected">
            <summary>
            failure states
            
            the remote end has disconnected from us
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SNetSocketState.ConnectionBroken">
            <summary>
            failure states
            
            connection has been broken; either the other end has disappeared or our local network connection has broke
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamAPICallFailure.None">
            <summary>
            No Failure
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamAPICallFailure.SteamGone">
            <summary>
            The local steam process has gone away
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamAPICallFailure.NetworkFailure">
            <summary>
            The network connection to Steam has been broken, or was already broken.
            SteamServersDisconnected callback will be sent around this time.
            SteamServersConnected will be sent when the client is able to talk to the Steam servers again.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamAPICallFailure.InvalidHandle">
            <summary>
            The SteamAPICall handle passed in no longer exists.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamAPICallFailure.MismatchedCallback">
            <summary>
            GetAPICallResult() was called with the wrong callback for this API call
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.SteamControllerState">
            <summary>
            
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamControllerState.packetNumber">
            <summary>
            If packet num matches that on your prior call, then the controller state hasn't been changed since 
            your last call and there is no need to process it
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamControllerState.buttons">
            <summary>
            Enum for the buttons, these are flags, so use bitwise operations.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamControllerState.LeftPadX">
            <summary>
            Left pad X coordinate
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamControllerState.LeftPadY">
            <summary>
            Left pad Y coordinate
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamControllerState.sRightPadX">
            <summary>
            Right pad X coordinate
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.SteamControllerState.sRightPadY">
            <summary>
            Right pad Y coordinate
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.SteamParamStringArray">
            <summary>
            Wrapper for the \a SteamParamStringArray_t struct.
            Contains a collection of strings.
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.UGCDetails">
            <summary>
            Wrapper for the \a SteamUGCDetails_t struct
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.Result">
            <summary>
            The result of the operation.
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.WorkshopFileType">
            <summary>
            Type of the file
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.CreatorAppID">
            <summary>
            ID of the app that created this file.
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.ConsumerAppID">
            <summary>
            ID of the app that will consume this file.
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.Title">
            <summary>
            title of document
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.Description">
            <summary>
            description of document
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.SteamIDOwner">
            <summary>
            Steam ID of the user who created this content.
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.TimeCreated">
            <summary>
            time when the published file was created
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.TimeUpdated">
            <summary>
            time when the published file was last updated
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.TimeAddedToUserList">
            <summary>
            time when the user added the published file to their list (not always applicable)
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.Visibility">
            <summary>
            visibility
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.Banned">
            <summary>
            whether the file was banned
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.AcceptedForUse">
            <summary>
            developer has specifically flagged this item as accepted in the Workshop
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.TagsTruncated">
            <summary>
            whether the list of tags was too long to be returned in the provided buffer
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.Tags">
            <summary>
            comma separated list of all tags associated with this file
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.File">
            <summary>
            The handle of the primary file
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.PreviewFile">
            <summary>
            The handle of the preview file
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.FileName">
            <summary>
            The cloud filename of the primary file
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.FileSize">
            <summary>
            Size of the primary file
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.PreviewFileSize">
            <summary>
            Size of the preview file
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.URL">
            <summary>
            URL (for a video or a website)
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.VotesUp">
            <summary>
            number of votes up
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.VotesDown">
            <summary>
            number of votes down
            </summary>
        </member>
        <member name="P:ManagedSteam.SteamTypes.UGCDetails.Score">
            <summary>
            calculated score
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.EUGCMatchingUGCType">
            <summary>
            Managed version of the \steamref UserUGCList enum
            
            Matching UGC types for queries
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.EUGCMatchingUGCType.Items">
            <summary>
            both mtx items and ready-to-use items
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.EUGCMatchingUGCType.AllGuides">
            <summary>
            both web guides and integrated guides
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.EUGCMatchingUGCType.UsableInGame">
            <summary>
            ready-to-use items and integrated guides
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.EUGCQuery">
            <summary>
            Managed version of the \steamref UserUGCList enum
            
            Combination of sorting and filtering for queries across all UGC
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.UGCReadAction">
            <summary>
            Managed version of the \steamref EUGCReadAction enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UGCReadAction.ContinueReadingUntilFinished">
            <summary>
            Keeps the file handle open unless the last byte is read.  You can use this when reading large files (over 100MB) in sequential chunks.
            If the last byte is read, this will behave the same as k_EUGCRead_Close.  Otherwise, it behaves the same as k_EUGCRead_ContinueReading
            This value maintains the same behavior as before the EUGCReadAction parameter was introduced.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UGCReadAction.ContinueReading">
            <summary>
            Keeps the file handle open.  Use this when using UGCRead to seek to different parts of the file.
            When you are done seeking around the file, make a final call with k_EUGCRead_Close to close it.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UGCReadAction.Close">
            <summary>
            Frees the file handle.  Use this when you're done reading the content.  
            To read the file from Steam again you will need to call UGCDownload again. 
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.Universe">
            <summary>
            Specifies the Universe this client is connected to.
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Universe.Invalid">
            <summary>
            Invalid Universe
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Universe.Public">
            <summary>
            Public Universe
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Universe.Beta">
            <summary>
            Beta Universe
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Universe.Internal">
            <summary>
            Internal Universe
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Universe.Dev">
            <summary>
            Dev Universe
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.Universe.RC">
            <summary>
            RC Universe
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.UserHasLicenseForAppResult">
            <summary>
            Managed version of the \a EUserhasLicenseForAppResult enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserHasLicenseForAppResult.HasLicense">
            <summary>
            User has a license for specified app
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserHasLicenseForAppResult.DoesNotHaveLicense">
            <summary>
            User does not have a license for the specified app
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserHasLicenseForAppResult.NoAuth">
            <summary>
            User has not been authenticated
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.UserRestriction">
            <summary>
            Managed version of the \a EUserRestriction enum
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserRestriction.None">
            <summary>
            no known chat/content restriction
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserRestriction.Unknown">
            <summary>
            we don't know yet (user offline)
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserRestriction.AnyChat">
            <summary>
            user is not allowed to (or can't) send/recv any chat
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserRestriction.VoiceChat">
            <summary>
            user is not allowed to (or can't) send/recv voice chat
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserRestriction.GroupChat">
            <summary>
            user is not allowed to (or can't) send/recv group chat
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserRestriction.Rating">
            <summary>
            user is too young according to rating in current region
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserRestriction.GameInvites">
            <summary>
            user cannot send or recv game invites (e.g. mobile)
            </summary>
        </member>
        <member name="F:ManagedSteam.SteamTypes.UserRestriction.Trading">
            <summary>
            user cannot participate in trading (console, mobile)
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.UserUGCList">
            <summary>
            Managed version of the \steamref UserUGCList enum
            
            Different lists of published UGC for a user.
            If the current logged in user is different than the specified user, then some options may not be allowed.
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.EUserUGCListSortOrder">
            <summary>
            Managed version of the \steamref UserUGCList enum
            
            Sort order for user published UGC lists (defaults to creation order descending)
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.WorkshopEnumerationType">
            <summary>
            Managed version of the \a EWorkshopEnumerationType enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.WorkshopFileAction">
            <summary>
            Managed version of the \a EWorkshopFileAction enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.WorkshopFileType">
            <summary>
            Managed version of the \a EWorkshopFileType enum
            </summary>
        </member>
        <member name="T:ManagedSteam.SteamTypes.WorkshopVote">
            <summary>
            Managed version of the \a EWorkshopVote enum
            </summary>
        </member>
        <member name="E:ManagedSteam.Utility.JobManager.PreCreateJob">
            <summary>
            Invoked before each job in RunCreateJobs
            </summary>
        </member>
        <member name="E:ManagedSteam.Utility.JobManager.PostCreateJob">
            <summary>
            Invoked after each job in RunCreateJobs
            </summary>
        </member>
        <member name="E:ManagedSteam.Utility.JobManager.PreDestroyJob">
            <summary>
            Invoked before each job is run
            </summary>
        </member>
        <member name="E:ManagedSteam.Utility.JobManager.PostDestroyJob">
            <summary>
            Invoked after each job is run
            </summary>
        </member>
        <member name="M:ManagedSteam.Utility.NativeBuffer.ReadFromUnmanagedMemory">
            <summary>
            Will copy data from the unmanaged memory buffer to the managed byte array
            </summary>
        </member>
        <member name="M:ManagedSteam.Utility.NativeBuffer.WriteToUnmanagedMemory">
            <summary>
            Will copy data from the managed byte array into the unmanaged memory
            </summary>
        </member>
        <member name="M:ManagedSteam.Utility.NativeBuffer.CopyToNative``1(``0)">
            <summary>
            Creates a native copy of the passed in object.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns>A NativeBuffer that contains all the data of the passed in object</returns>
        </member>
        <member name="T:ManagedSteam.Utility.NativeString">
            <summary>
            A wrapper class that can convert to and from a managed string in different encodings
            </summary>
        </member>
        <member name="M:ManagedSteam.Utility.NativeString.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="nativeString">Pointer to the unmanaged memory containing the string. 
            Will only read from this memory location</param>
        </member>
        <member name="T:ManagedSteam.Utility.StringHelper">
            <summary>
            Helper class for some string related operations
            </summary>
        </member>
        <member name="M:ManagedSteam.Utility.StringHelper.GetByteCountUtf8(System.String)">
            <summary>
            Counts how many bytes the string will use, including the null terminator. Uses UTF8 encoding.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:ManagedSteam.UtilsGetImageSizeResult">
            <summary>
            ReturnStruct for the alternative verison of GetImageSize:
            
            </summary>
        </member>
        <member name="T:ManagedSteam.UtilsGetCSERIPPortResult">
            <summary>
            ReturnStruct for the alternative version of GetCSERIPPort:
            bool GetCSERIPPort(out uint unIP, out ushort usPort);
            </summary>
        </member>
        <member name="T:ManagedSteam.UtilsGetEnteredGamepadTextInputResult">
            <summary>
            ReturnStruct for the alternative version of GetEnteredGamepadTextInput:
            bool GetEnteredGamepadTextInput(out string pchText);
            </summary>
        </member>
        <member name="F:NativeConstants.INTEROP_CONVERSION">
             INTEROP_CONVERSION -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.ManagedSteam_API">
             ManagedSteam_API -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.ManagedSteam_API_Lite">
             ManagedSteam_API_Lite -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.Types_h_">
             Types_h_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.STEAMTYPES_H">
             STEAMTYPES_H -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.SW_MANAGED_CALLBACK_TYPE">
            Warning: Generation of Method Macros is not supported at this time
            SW_MANAGED_CALLBACK_TYPE -> "(returnType,callbackName,parameters) typedef returnType (__stdcall *callbackName)parameters"
        </member>
        <member name="F:NativeConstants.RemoteStorage_h_interop_">
             RemoteStorage_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.Services_h_interop_">
             Services_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.Stats_h_interop_">
             Stats_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.SteamUser_h_interop_">
             SteamUser_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.Friends_h_interop_">
             Friends_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.MatchMaking_h_interop_">
             MatchMaking_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.MatchmakingServers_h_interop_">
             MatchmakingServers_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.MatchmakingServerListResponse_h_interop_">
             MatchmakingServerListResponse_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.MatchmakingPingResponse_h_interop_">
             MatchmakingPingResponse_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.MatchmakingPlayers_h_interop_">
             MatchmakingPlayers_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.MatchmakingRulesPlayers_h_interop_">
             MatchmakingRulesPlayers_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.GameServer_h_interop_">
             GameServer_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.GameServerStats_h_interop_">
             GameServerStats_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.Networking_h_interop_">
             Networking_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.ServicesGameServer_h_interop_">
             ServicesGameServer_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="F:NativeConstants.Utils_h_interop_">
             Utils_h_interop_ -> 
             Error generating expression: Value cannot be null.
            Parameter name: node
        </member>
        <member name="T:ManagedCallback">
             Return Type: void
            id: Enum->s32->int32->int
            data: PConstantDataPointer->void*
            dataSize: s32->int32->int
        </member>
        <member name="T:ManagedResultCallback">
             Return Type: void
            id: Enum->s32->int32->int
            data: PConstantDataPointer->void*
            dataSize: s32->int32->int
            ioFailure: boolean
        </member>
        <member name="T:MatchmakingServerListResponse_ServerRespondedCallback">
             Return Type: void
            sender: uptr->uintp->unsigned int
            request: uptr->uintp->unsigned int
            server: s32->int32->int
        </member>
        <member name="T:MatchmakingServerListResponse_ServerFailedToRespond">
             Return Type: void
            sender: uptr->uintp->unsigned int
            request: uptr->uintp->unsigned int
            server: s32->int32->int
        </member>
        <member name="T:MatchmakingServerListResponse_RefreshComplete">
             Return Type: void
            sender: uptr->uintp->unsigned int
            request: uptr->uintp->unsigned int
            response: Enum->s32->int32->int
        </member>
        <member name="T:MatchmakingPingResponse_ServerRespondedCallback">
             Return Type: void
            sender: uptr->uintp->unsigned int
            server: PDataPointer->void*
            serverSize: s32->int32->int
        </member>
        <member name="T:MatchmakingPingResponse_ServerFailedToRespond">
             Return Type: void
            sender: uptr->uintp->unsigned int
        </member>
        <member name="T:MatchmakingPlayersResponse_AddPlayerToList">
             Return Type: void
            sender: uptr->uintp->unsigned int
            name: PConstantDataPointer->void*
            score: s32->int32->int
            timePlayed: f32->float
        </member>
        <member name="T:MatchmakingPlayersResponse_PlayersFailedToRespond">
             Return Type: void
            sender: uptr->uintp->unsigned int
        </member>
        <member name="T:MatchmakingPlayersResponse_PlayersRefreshComplete">
             Return Type: void
            sender: uptr->uintp->unsigned int
        </member>
        <member name="T:MatchmakingRulesResponse_RulesResponded">
             Return Type: void
            sender: uptr->uintp->unsigned int
            key: PConstantDataPointer->void*
            value: PConstantDataPointer->void*
        </member>
        <member name="T:MatchmakingRulesResponse_RulesFailedToRespond">
             Return Type: void
            sender: uptr->uintp->unsigned int
        </member>
        <member name="T:MatchmakingRulesResponse_RulesRefreshComplete">
             Return Type: void
            sender: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.Cloud_Write(System.String,System.IntPtr,System.Int32)">
             Return Type: boolean
            fileName: PConstantString->char*
            buffer: PConstantDataPointer->void*
            bufferLength: s32->int32->int
        </member>
        <member name="M:NativeMethods.Cloud_Read(System.String,System.IntPtr,System.Int32)">
             Return Type: s32->int32->int
            fileName: PConstantString->char*
            buffer: PDataPointer->void*
            bufferLength: s32->int32->int
        </member>
        <member name="M:NativeMethods.Cloud_Forget(System.String)">
             Return Type: boolean
            fileName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_Delete(System.String)">
             Return Type: boolean
            fileName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_Share(System.String)">
             Return Type: void
            fileName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_SetSyncPlatforms(System.String,System.Int32)">
             Return Type: boolean
            fileName: PConstantString->char*
            remoteStoragePlatform: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Cloud_Exists(System.String)">
             Return Type: boolean
            fileName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_Persisted(System.String)">
             Return Type: boolean
            fileName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_GetSize(System.String)">
             Return Type: s32->int32->int
            fileName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_Timestamp(System.String)">
             Return Type: s64->int64->__int64
            fileName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_GetSyncPlatforms(System.String)">
             Return Type: Enum->s32->int32->int
            fileName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_GetFileCount">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.Cloud_GetFileNameAndSize(System.Int32,System.Int32@)">
             Return Type: PConstantString->char*
            fileID: s32->int32->int
            fileSize: s32*
        </member>
        <member name="M:NativeMethods.Cloud_GetQuota(System.Int32@,System.Int32@)">
             Return Type: boolean
            totalBytes: s32*
            availableBytes: s32*
        </member>
        <member name="M:NativeMethods.Cloud_IsEnabledForAccount">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Cloud_IsEnabledForApplication">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Cloud_SetEnabledForApplication(System.Boolean)">
             Return Type: void
            enabled: boolean
        </member>
        <member name="M:NativeMethods.Cloud_UGCDownload(System.UInt64,System.UInt32)">
             Return Type: void
            handle: UGCHandle->u64->uint64->unsigned __int64
            unPriority: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Cloud_GetUGCDownloadProgress(System.UInt64,System.Int32@,System.Int32@)">
             Return Type: boolean
            handle: UGCHandle->u64->uint64->unsigned __int64
            bytesDownloaded: s32*
            bytesExpected: s32*
        </member>
        <member name="M:NativeMethods.Cloud_GetUGCDetails(System.UInt64,System.UInt32@,System.IntPtr@,System.Int32@,System.UInt64@)">
             Return Type: boolean
            handle: UGCHandle->u64->uint64->unsigned __int64
            appID: u32*
            name: char**
            fileSize: s32*
            creator: SteamID*
        </member>
        <member name="M:NativeMethods.Cloud_UGCRead(System.UInt64,System.IntPtr,System.Int32,System.UInt32,System.Int32)">
             Return Type: s32->int32->int
            handle: UGCHandle->u64->uint64->unsigned __int64
            buffer: PDataPointer->void*
            bufferLength: s32->int32->int
            offset: u32->uint32->unsigned int
            action: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Cloud_GetCachedUGCCount">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.Cloud_GetUGCHandle(System.Int32)">
             Return Type: UGCHandle->u64->uint64->unsigned __int64
            handleID: s32->int32->int
        </member>
        <member name="M:NativeMethods.Cloud_PublishWorkshopFile(System.String,System.String,System.UInt32,System.String,System.String,System.Int32,System.IntPtr,System.Int32)">
             Return Type: void
            fileName: PConstantString->char*
            previewFile: PConstantString->char*
            consumerAppId: u32->uint32->unsigned int
            title: PConstantString->char*
            description: PConstantString->char*
            visibility: Enum->s32->int32->int
            tags: PDataPointer->void*
            workshopFileType: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Cloud_CreatePublishedFileUpdateRequest(System.UInt64)">
             Return Type: PublishedFileUpdateHandle->u64->uint64->unsigned __int64
            publishedFileId: PublishedFileId->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Cloud_UpdatePublishedFileFile(System.UInt64,System.String)">
             Return Type: boolean
            updateHandle: PublishedFileUpdateHandle->u64->uint64->unsigned __int64
            file: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_UpdatePublishedFilePreviewFile(System.UInt64,System.String)">
             Return Type: boolean
            updateHandle: PublishedFileUpdateHandle->u64->uint64->unsigned __int64
            previewFile: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_UpdatePublishedFileTitle(System.UInt64,System.String)">
             Return Type: boolean
            updateHandle: PublishedFileUpdateHandle->u64->uint64->unsigned __int64
            title: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_UpdatePublishedFileDescription(System.UInt64,System.String)">
             Return Type: boolean
            updateHandle: PublishedFileUpdateHandle->u64->uint64->unsigned __int64
            description: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_UpdatePublishedFileVisibility(System.UInt64,System.Int32)">
             Return Type: boolean
            updateHandle: PublishedFileUpdateHandle->u64->uint64->unsigned __int64
            visibility: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Cloud_UpdatePublishedFileTags(System.UInt64,System.IntPtr)">
             Return Type: boolean
            updateHandle: PublishedFileUpdateHandle->u64->uint64->unsigned __int64
            tags: PDataPointer->void*
        </member>
        <member name="M:NativeMethods.Cloud_CommitPublishedFileUpdate(System.UInt64)">
             Return Type: void
            updateHandle: PublishedFileUpdateHandle->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Cloud_GetPublishedFileDetails(System.UInt64,System.UInt32)">
             Return Type: void
            publishedFileId: PublishedFileId->u64->uint64->unsigned __int64
            maxSecondsOld: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Cloud_DeletePublishedFile(System.UInt64)">
             Return Type: void
            publishedFileId: PublishedFileId->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Cloud_EnumerateUserPublishedFiles(System.UInt32)">
             Return Type: void
            startIndex: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Cloud_SubscribePublishedFile(System.UInt64)">
             Return Type: void
            publishedFileId: PublishedFileId->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Cloud_EnumerateUserSubscribedFiles(System.UInt32)">
             Return Type: void
            startIndex: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Cloud_UnsubscribePublishedFile(System.UInt64)">
             Return Type: void
            publishedFileId: PublishedFileId->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Cloud_UpdatePublishedFileSetChangeDescription(System.UInt64,System.String)">
             Return Type: boolean
            updateHandle: PublishedFileUpdateHandle->u64->uint64->unsigned __int64
            changeDescription: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Cloud_GetPublishedItemVoteDetails(System.UInt64)">
             Return Type: void
            publishedFileId: PublishedFileId->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Cloud_UpdateUserPublishedItemVote(System.UInt64,System.Boolean)">
             Return Type: void
            publishedFileId: PublishedFileId->u64->uint64->unsigned __int64
            voteUp: boolean
        </member>
        <member name="M:NativeMethods.Cloud_GetUserPublishedItemVoteDetails(System.UInt64)">
             Return Type: void
            publishedFileId: PublishedFileId->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Cloud_EnumerateUserSharedWorkshopFiles(System.UInt64,System.UInt32,System.IntPtr,System.IntPtr)">
             Return Type: void
            steamId: SteamID->u64->uint64->unsigned __int64
            startIndex: u32->uint32->unsigned int
            requiredTags: PDataPointer->void*
            excludedTags: PDataPointer->void*
        </member>
        <member name="M:NativeMethods.Cloud_PublishVideo(System.Int32,System.String,System.String,System.String,System.UInt32,System.String,System.String,System.Int32,System.IntPtr)">
            Return Type: void
            videoProvider: Enum->s32->int32->int
            videoAccount: PConstantString->char*
            videoIdentifier: PConstantString->char*
            videoPreview: PConstantString->char*
            consumerAppId: AppID->u32->uint32->unsigned int
            title: PConstantString->char*
            description: PConstantString->char*
            visibility: Enum->s32->int32->int
            PDataPointer->void*
        </member>
        <member name="M:NativeMethods.Cloud_SetUserPublishedFileAction(System.UInt64,System.Int32)">
             Return Type: void
            publishedFileId: PublishedFileId->u64->uint64->unsigned __int64
            action: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Cloud_EnumeratePublishedFilesByUserAction(System.Int32,System.UInt32)">
             Return Type: void
            action: Enum->s32->int32->int
            startIndex: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Cloud_EnumeratePublishedWorkshopFiles(System.Int32,System.UInt32,System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)">
             Return Type: void
            enumerationType: Enum->s32->int32->int
            startIndex: u32->uint32->unsigned int
            count: u32->uint32->unsigned int
            days: u32->uint32->unsigned int
            tags: PDataPointer->void*
            userTags: PDataPointer->void*
        </member>
        <member name="M:NativeMethods.Cloud_UGCDownloadToLocation(System.UInt64,System.String,System.UInt32)">
            Return Type: void
            content: UGCHandle->u64->uint64->unsigned __int64
            location: PConstantString->char*
            priority: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Services_GetInterfaceVersion">
            Return Type: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Services_GetErrorCode">
            Return Type: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Services_Startup(System.UInt32)">
             Return Type: boolean
            interfaceVersion: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Services_Shutdown">
            Return Type: void
        </member>
        <member name="M:NativeMethods.Services_IsSteamRunning">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Services_RestartAppIfNecessary(System.UInt32)">
            Return Type: boolean
            ownAppID: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Services_GetSteamLoadStatus">
            Return Type: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Services_HandleCallbacks">
            Return Type: void
        </member>
        <member name="M:NativeMethods.Services_GetAppID">
            Return Type: u32->uint->unsigned int
        </member>
        <member name="M:NativeMethods.Services_RegisterManagedCallbacks(ManagedCallback,ManagedResultCallback)">
             Return Type: void
            callback: ManagedCallback
            resultCallback: ManagedResultCallback
        </member>
        <member name="M:NativeMethods.Services_RemoveManagedCallbacks">
            Return Type: void
        </member>
        <member name="M:NativeMethods.Stats_RequestCurrentStats">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Stats_GetStatInt(System.String,System.Int32@)">
             Return Type: boolean
            name: PConstantString->char*
            data: s32*
        </member>
        <member name="M:NativeMethods.Stats_GetStatFloat(System.String,System.Single@)">
             Return Type: boolean
            name: PConstantString->char*
            data: float*
        </member>
        <member name="M:NativeMethods.Stats_SetStatInt(System.String,System.Int32)">
             Return Type: boolean
            name: PConstantString->char*
            data: s32->int32->int
        </member>
        <member name="M:NativeMethods.Stats_SetStatFloat(System.String,System.Single)">
             Return Type: boolean
            name: PConstantString->char*
            data: float
        </member>
        <member name="M:NativeMethods.Stats_UpdateAverageRateStat(System.String,System.Single,System.Double)">
             Return Type: boolean
            name: PConstantString->char*
            countThisSession: float
            sessionLength: double
        </member>
        <member name="M:NativeMethods.Stats_GetAchievement(System.String,System.Boolean@)">
             Return Type: boolean
            name: PConstantString->char*
            achieved: boolean*
        </member>
        <member name="M:NativeMethods.Stats_SetAchievement(System.String)">
             Return Type: boolean
            name: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Stats_ClearAchievement(System.String)">
             Return Type: boolean
            name: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Stats_GetAchievementAndUnlockTime(System.String,System.Boolean@,System.UInt32@)">
             Return Type: boolean
            name: PConstantString->char*
            achieved: boolean*
            unlockTime: u32*
        </member>
        <member name="M:NativeMethods.Stats_StoreStats">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Stats_GetAchievementIcon(System.String)">
             Return Type: s32->int32->int
            name: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Stats_GetAchievementDisplayAttribute(System.String,System.String)">
             Return Type: PConstantString->char*
            name: PConstantString->char*
            key: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Stats_IndicateAchievementProgress(System.String,System.UInt32,System.UInt32)">
             Return Type: boolean
            name: PConstantString->char*
            currentProgress: u32->uint32->unsigned int
            maxProgess: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Stats_RequestUserStats(System.UInt64)">
             Return Type: void
            steamID: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Stats_GetUserStatInt(System.UInt64,System.String,System.Int32@)">
             Return Type: boolean
            steamID: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
            data: s32*
        </member>
        <member name="M:NativeMethods.Stats_GetUserStatFloat(System.UInt64,System.String,System.Single@)">
             Return Type: boolean
            steamID: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
            data: float*
        </member>
        <member name="M:NativeMethods.Stats_GetUserAchievement(System.UInt64,System.String,System.Boolean@)">
             Return Type: boolean
            steamID: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
            achieved: boolean*
        </member>
        <member name="M:NativeMethods.Stats_GetUserAchievementAndUnlockTime(System.UInt64,System.String,System.Boolean@,System.UInt32@)">
             Return Type: boolean
            steamID: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
            achieved: boolean*
            unlockTime: u32*
        </member>
        <member name="M:NativeMethods.Stats_ResetAllStats(System.Boolean)">
             Return Type: boolean
            achievementsToo: boolean
        </member>
        <member name="M:NativeMethods.Stats_FindOrCreateLeaderboard(System.String,System.Int32,System.Int32)">
             Return Type: void
            name: PConstantString->char*
            sortMethod: Enum->s32->int32->int
            displayType: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Stats_FindLeaderboard(System.String)">
             Return Type: void
            name: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Stats_GetLeaderboardName(System.UInt64)">
             Return Type: PConstantString->char*
            handle: SteamLeaderboard->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Stats_GetLeaderboardEntryCount(System.UInt64)">
             Return Type: s32->int32->int
            handle: SteamLeaderboard->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Stats_GetLeaderboardSortMethod(System.UInt64)">
             Return Type: Enum->s32->int32->int
            handle: SteamLeaderboard->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Stats_GetLeaderboardDisplayType(System.UInt64)">
             Return Type: Enum->s32->int32->int
            handle: SteamLeaderboard->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Stats_DownloadLeaderboardEntries(System.UInt64,System.Int32,System.Int32,System.Int32)">
             Return Type: void
            handle: SteamLeaderboard->u64->uint64->unsigned __int64
            dataRequest: Enum->s32->int32->int
            start: s32->int32->int
            end: s32->int32->int
        </member>
        <member name="M:NativeMethods.Stats_DownloadLeaderboardEntriesForUsers(System.UInt64,System.IntPtr,System.Int32)">
             Return Type: void
            handle: SteamLeaderboard->u64->uint64->unsigned __int64
            users: PConstantDataPointer->void*
            numberOfUsers: s32->int32->int
        </member>
        <member name="M:NativeMethods.Stats_GetDownloadedLeaderboardEntry(System.UInt64,System.Int32,System.IntPtr,System.IntPtr,System.Int32)">
             Return Type: boolean
            entries: SteamLeaderboardEntries->u64->uint64->unsigned __int64
            index: s32->int32->int
            entry: PDataPointer->void*
            detailsBuffer: PDataPointer->void*
            maxDetails: s32->int32->int
        </member>
        <member name="M:NativeMethods.Stats_UploadLeaderboardScore(System.UInt64,System.Int32,System.Int32,System.IntPtr,System.Int32)">
             Return Type: void
            handle: SteamLeaderboard->u64->uint64->unsigned __int64
            scoreMethod: Enum->s32->int32->int
            score: s32->int32->int
            details: PConstantDataPointer->void*
            detailsCount: s32->int32->int
        </member>
        <member name="M:NativeMethods.Stats_AttachLeaderboardUGC(System.UInt64,System.UInt64)">
             Return Type: void
            handle: SteamLeaderboard->u64->uint64->unsigned __int64
            ugcHandle: UGCHandle->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Stats_GetNumberOfCurrentPlayers">
            Return Type: void
        </member>
        <member name="M:NativeMethods.Stats_RequestGlobalAchievementPercentages">
            Return Type: void
        </member>
        <member name="M:NativeMethods.Stats_GetMostAchievedAchievementInfo(System.IntPtr,System.UInt32,System.Single@,System.Boolean@)">
             Return Type: s32->int32->int
            name: PString->char*
            nameLength: u32->uint32->unsigned int
            percent: float*
            achieved: boolean*
        </member>
        <member name="M:NativeMethods.Stats_GetNextMostAchievedAchievementInfo(System.Int32,System.IntPtr,System.UInt32,System.Single@,System.Boolean@)">
             Return Type: s32->int32->int
            iterator: s32->int32->int
            name: PString->char*
            nameLength: u32->uint32->unsigned int
            percent: float*
            achieved: boolean*
        </member>
        <member name="M:NativeMethods.Stats_GetAchievementAchievedPercent(System.String,System.Single@)">
             Return Type: boolean
            name: PConstantString->char*
            percent: float*
        </member>
        <member name="M:NativeMethods.Stats_RequestGlobalStats(System.Int32)">
             Return Type: void
            historyDays: s32->int32->int
        </member>
        <member name="M:NativeMethods.Stats_GetGlobalStatInt(System.String,System.Int64@)">
             Return Type: boolean
            name: PConstantString->char*
            data: s64*
        </member>
        <member name="M:NativeMethods.Stats_GetGlobalStatDouble(System.String,System.Double@)">
             Return Type: boolean
            name: PConstantString->char*
            data: double*
        </member>
        <member name="M:NativeMethods.Stats_GetGlobalStatHistoryInt(System.String,System.IntPtr,System.UInt32)">
             Return Type: s32->int32->int
            name: PConstantString->char*
            dataBuffer: PDataPointer->void*
            bufferSize: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Stats_GetGlobalStatHistoryDouble(System.String,System.IntPtr,System.UInt32)">
             Return Type: s32->int32->int
            name: PConstantString->char*
            dataBuffer: PDataPointer->void*
            bufferSize: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.User_IsLoggedOn">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.User_GetSteamID">
            Return Type: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.User_InitiateGameConnection(System.IntPtr,System.Int32,System.UInt64,System.UInt32,System.UInt16,System.Boolean)">
            Return Type: s32->int32->int
            authBlob: PDataPointer->void*
            maxAuthBlob: s32->int->int
            steamIDGameServer: SteamID->u64->uint64->unsigned __int64 (ulong)
            serverIP: u32->uint32->unsigned int
            serverPort: u16->uint16->unsigned short
            secure: boolean
        </member>
        <member name="M:NativeMethods.User_TerminateGameConnection(System.UInt32,System.UInt16)">
            Return Type: void
            serverIP: u32->uint32->unsigned int
            serverPort: u16->uint16->unsigned short
        </member>
        <member name="M:NativeMethods.User_TrackAppUsageEvent(System.UInt64,System.Int32,System.String)">
            Return Type: void
            gameID: GameID->u64->uint64->unsigned __int64
            appUsageEvent: s32->int32->int
            extraInfo: PConstantString->char*
        </member>
        <member name="M:NativeMethods.User_GetUserDataFolder(System.IntPtr,System.Int32)">
            Return Type: boolean
            buffer: PString->char*
            bufferLength: s32->int32->int
        </member>
        <member name="M:NativeMethods.User_StartVoiceRecording">
            Return Type: void
        </member>
        <member name="M:NativeMethods.User_StopVoiceRecording">
            Return Type: void
        </member>
        <member name="M:NativeMethods.User_GetAvailableVoice(System.UInt32@,System.UInt32@,System.UInt32)">
            Return Type: Enum->s32->int32->int
            compressed: u32*
            uncompressed: u32*
            uncompressedVoiceDesiredSampleRate: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.User_GetVoice(System.Boolean,System.IntPtr,System.UInt32,System.UInt32@,System.Boolean,System.IntPtr,System.UInt32,System.UInt32@,System.UInt32)">
            Return Type: Enum->s32->int32->int
            wantCompressed: boolean
            destBuffer: PDataPointer->void*
            destBufferSize: u32->uint32->unsigned int
            bytesWritten: u32*
            wantUncompressed: boolean
            uncompressedDestBuffer: PDataPointer->void*
            uncompressedDestBufferSize: u32->uint32->unsigned int 
            uncompressedBytesWritten: u32*
            uncompressedVoiceDesiredSampleRate: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.User_DecompressVoice(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32@,System.UInt32)">
            Return Type: Enum->s32->int32->int
            compressed: PConstantDataPointer->void*
            compressedSize: u32->uint32->unsigned int
            destBuffer: PDataPointer->void*
            destBufferSize: u32->uint32->unsigned int
            bytesWritten: u32*
            desiredSampleRate: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.User_GetVoiceOptimalSampleRate">
            Return Type: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.User_GetAuthSessionTicket(System.IntPtr,System.Int32,System.UInt32@)">
            Return Type: AuthTicket->u32->uint32->unsigned int
            ticket: PDataPointer->void*
            maxTicket: s32->int32->int
            ticketLength: u32*
        </member>
        <member name="M:NativeMethods.User_BeginAuthSession(System.IntPtr,System.Int32,System.UInt64)">
            Return Type: Enum->s32->int32->int
            authTicket: PConstantDataPointer->void*
            cbAuthTicket: s32->int32->int
            steamID: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.User_EndAuthSession(System.UInt64)">
            Return Type: void
            steamID: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.User_CancelAuthTicket(System.UInt32)">
            Return Type: void
            authTicket: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.User_UserHasLicenseForApp(System.UInt64,System.UInt32)">
            Return Type: Enum->s32->int32->int
            steamID: SteamID->u64->uint64->unsigned __int64
            appID: AppID->u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.User_IsBehindNAT">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.User_AdvertiseGame(System.UInt64,System.UInt32,System.UInt16)">
            Return Type: void
            steamIDGameServer: SteamID->u64->uint64->unsigned __int64
            serverIP: u32->uint32->unsigned int
            serverPort: u16->uint16->unsigned short
        </member>
        <member name="M:NativeMethods.User_RequestEncryptedAppTicket(System.IntPtr,System.Int32)">
            Return Type: void
            dataToInclude: PDataPointer->void*
            cbDataToInclude: s32->int32->int
        </member>
        <member name="M:NativeMethods.User_GetEncryptedAppTicket(System.IntPtr,System.Int32,System.UInt32@)">
            Return Type: boolean
            ticket: PDataPointer->void*
            maxTicket: s32->int32->int
            ticketLength: u32*
        </member>
        <member name="M:NativeMethods.User_GetGameBadgeLevel(System.Int32,System.Boolean)">
            Return Type: s32->int32->int
            nSeries: s32->int32->int
            bFoil: boolean
        </member>
        <member name="M:NativeMethods.User_GetPlayerSteamLevel">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetPersonaName">
            Return Type: PConstantUtf8String->void*
        </member>
        <member name="M:NativeMethods.Friends_SetPersonaName(System.IntPtr)">
             Return Type: void
            personaName: PConstantUtf8String->void*
        </member>
        <member name="M:NativeMethods.Friends_GetPersonaState">
            Return Type: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetFriendCount(System.Int32)">
             Return Type: s32->int32->int
            friendFlags: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetFriendByIndex(System.Int32,System.Int32)">
             Return Type: SteamID->u64->uint64->unsigned __int64
            friendIndex: s32->int32->int
            friendFlags: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetFriendRelationship(System.UInt64)">
             Return Type: Enum->s32->int32->int
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetFriendPersonaState(System.UInt64)">
             Return Type: Enum->s32->int32->int
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetFriendPersonaName(System.UInt64)">
             Return Type: PConstantUtf8String->void*
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetFriendGamePlayed(System.UInt64,System.IntPtr)">
             Return Type: boolean
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
            friendGameInfo: PDataPointer->void*
        </member>
        <member name="M:NativeMethods.Friends_GetFriendGameInfoSize">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetFriendPersonaNameHistory(System.UInt64,System.Int32)">
             Return Type: PConstantUtf8String->void*
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
            personaName: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetPlayerNickname(System.UInt64)">
             Return Type: PConstantUtf8String->void*
            steamIDPlayer: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_HasFriend(System.UInt64,System.Int32)">
             Return Type: boolean
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
            friendFlags: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetClanCount">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetClanByIndex(System.Int32)">
             Return Type: SteamID->u64->uint64->unsigned __int64
            clan: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetClanName(System.UInt64)">
             Return Type: PConstantString->char*
            steamIDClan: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetClanTag(System.UInt64)">
             Return Type: PConstantString->char*
            steamIDClan: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetClanActivityCounts(System.UInt64,System.Int32@,System.Int32@,System.Int32@)">
             Return Type: boolean
            steamIDClan: SteamID->u64->uint64->unsigned __int64
            online: s32*
            inGame: s32*
            chatting: s32*
        </member>
        <member name="M:NativeMethods.Friends_DownloadClanActivityCounts(System.IntPtr,System.Int32)">
             Return Type: void
            steamIDClans: PConstantDataPointer->void*
            clansToRequest: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetFriendCountFromSource(System.UInt64)">
             Return Type: s32->int32->int
            steamIDSource: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetFriendFromSourceByIndex(System.UInt64,System.Int32)">
             Return Type: SteamID->u64->uint64->unsigned __int64
            steamIDSource: SteamID->u64->uint64->unsigned __int64
            friendIndex: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_IsUserInSource(System.UInt64,System.UInt64)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            steamIDSource: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_SetInGameVoiceSpeaking(System.UInt64,System.Boolean)">
             Return Type: void
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            speaking: boolean
        </member>
        <member name="M:NativeMethods.Friends_ActivateGameOverlay(System.Int32)">
             Return Type: void
            dialogType: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_ActivateGameOverlayToUser(System.Int32,System.UInt64)">
             Return Type: void
            dialogType: Enum->s32->int32->int
            steamID: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_ActivateGameOverlayToWebPage(System.String)">
             Return Type: void
            url: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Friends_ActivateGameOverlayToStore(System.UInt32,System.Int32)">
            Return Type: void
            appID: AppID->u32->uint32->unsigned int
            flag: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_SetPlayedWith(System.UInt64)">
             Return Type: void
            steamIDUserPlayedWith: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_ActivateGameOverlayInviteDialog(System.UInt64)">
             Return Type: void
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetSmallFriendAvatar(System.UInt64)">
             Return Type: s32->int32->int
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetMediumFriendAvatar(System.UInt64)">
             Return Type: s32->int32->int
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetLargeFriendAvatar(System.UInt64)">
             Return Type: s32->int32->int
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_RequestUserInformation(System.UInt64,System.Boolean)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            requireNameOnly: boolean
        </member>
        <member name="M:NativeMethods.Friends_RequestClanOfficerList(System.UInt64)">
             Return Type: void
            steamIDClan: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetClanOwner(System.UInt64)">
             Return Type: SteamID->u64->uint64->unsigned __int64
            steamIDClan: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetClanOfficerCount(System.UInt64)">
             Return Type: s32->int32->int
            steamIDClan: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetClanOfficerByIndex(System.UInt64,System.Int32)">
             Return Type: SteamID->u64->uint64->unsigned __int64
            steamIDClan: SteamID->u64->uint64->unsigned __int64
            officer: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetUserRestrictions">
            Return Type: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Friends_SetRichPresence(System.String,System.IntPtr)">
             Return Type: boolean
            key: PConstantString->char*
            value: PConstantUtf8String->void*
        </member>
        <member name="M:NativeMethods.Friends_ClearRichPresence">
            Return Type: void
        </member>
        <member name="M:NativeMethods.Friends_GetFriendRichPresence(System.UInt64,System.String)">
             Return Type: PConstantUtf8String->void*
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
            key: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Friends_GetFriendRichPresenceKeyCount(System.UInt64)">
             Return Type: s32->int32->int
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetFriendRichPresenceKeyByIndex(System.UInt64,System.Int32)">
             Return Type: PConstantUtf8String->void*
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
            key: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_RequestFriendRichPresence(System.UInt64)">
             Return Type: void
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_InviteUserToGame(System.UInt64,System.String)">
             Return Type: boolean
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
            connectString: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Friends_GetCoplayFriendCount">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetCoplayFriend(System.Int32)">
             Return Type: SteamID->u64->uint64->unsigned __int64
            coplayFriend: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_GetFriendCoplayTime(System.UInt64)">
             Return Type: s32->int32->int
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetFriendCoplayGame(System.UInt64)">
             Return Type: AppID->u32->uint32->unsigned int
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_JoinClanChatRoom(System.UInt64)">
             Return Type: void
            steamIDClan: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_LeaveClanChatRoom(System.UInt64)">
             Return Type: boolean
            steamIDClan: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetClanChatMemberCount(System.UInt64)">
             Return Type: s32->int32->int
            steamIDClan: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_GetChatMemberByIndex(System.UInt64,System.Int32)">
             Return Type: SteamID->u64->uint64->unsigned __int64
            steamIDClan: SteamID->u64->uint64->unsigned __int64
            user: s32->int32->int
        </member>
        <member name="M:NativeMethods.Friends_SendClanChatMessage(System.UInt64,System.IntPtr)">
             Return Type: boolean
            steamIDClanChat: SteamID->u64->uint64->unsigned __int64
            text: PConstantUtf8String->void*
        </member>
        <member name="M:NativeMethods.Friends_GetClanChatMessage(System.UInt64,System.Int32,System.IntPtr,System.Int32,System.Int32@,System.UInt64@)">
             Return Type: s32->int32->int
            steamIDClanChat: SteamID->u64->uint64->unsigned __int64
            message: s32->int32->int
            text: PUtf8String->void*
            textSize: s32->int32->int
            chatEntryType: Enum*
            sender: SteamID*
        </member>
        <member name="M:NativeMethods.Friends_IsClanChatAdmin(System.UInt64,System.UInt64)">
             Return Type: boolean
            steamIDClanChat: SteamID->u64->uint64->unsigned __int64
            steamIDUser: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_IsClanChatWindowOpenInSteam(System.UInt64)">
             Return Type: boolean
            steamIDClanChat: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_OpenClanChatWindowInSteam(System.UInt64)">
             Return Type: boolean
            steamIDClanChat: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_CloseClanChatWindowInSteam(System.UInt64)">
             Return Type: boolean
            steamIDClanChat: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_SetListenForFriendsMessages(System.Boolean)">
             Return Type: boolean
            interceptEnabled: boolean
        </member>
        <member name="M:NativeMethods.Friends_ReplyToFriendMessage(System.UInt64,System.IntPtr)">
             Return Type: boolean
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
            msgToSend: PConstantUtf8String->void*
        </member>
        <member name="M:NativeMethods.Friends_GetFriendMessage(System.UInt64,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
             Return Type: s32->int32->int
            steamIDFriend: SteamID->u64->uint64->unsigned __int64
            messageID: s32->int32->int
            text: PUtf8String->void*
            textSize: s32->int32->int
            chatEntryType: Enum*
        </member>
        <member name="M:NativeMethods.Friends_GetFollowerCount(System.UInt64)">
             Return Type: void
            steamID: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_IsFollowing(System.UInt64)">
             Return Type: void
            steamID: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Friends_EnumerateFollowingList(System.UInt32)">
             Return Type: void
            startIndex: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.MatchMaking_GetFavoriteGameCount">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_GetFavoriteGame(System.Int32,System.UInt32@,System.UInt32@,System.UInt16@,System.UInt16@,System.UInt32@,System.UInt32@)">
             Return Type: boolean
            game: s32->int32->int
            appID: u32*
            ip: u32*
            connPort: u16*
            queryPort: u16*
            flags: u32*
            time32LastPlayedOnServer: u32*
        </member>
        <member name="M:NativeMethods.MatchMaking_AddFavoriteGame(System.UInt32,System.UInt32,System.UInt16,System.UInt16,System.UInt32,System.UInt32)">
             Return Type: s32->int32->int
            appID: u32->uint32->unsigned int
            ip: u32->uint32->unsigned int
            connPort: u16->uint16->unsigned short
            queryPort: u16->uint16->unsigned short
            flags: u32->uint32->unsigned int
            time32LastPlayedOnServer: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.MatchMaking_RemoveFavoriteGame(System.UInt32,System.UInt32,System.UInt16,System.UInt16,System.UInt32)">
             Return Type: boolean
            appID: u32->uint32->unsigned int
            IP: u32->uint32->unsigned int
            connPort: u16->uint16->unsigned short
            queryPort: u16->uint16->unsigned short
            flags: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.MatchMaking_RequestLobbyList">
            Return Type: void
        </member>
        <member name="M:NativeMethods.MatchMaking_AddRequestLobbyListStringFilter(System.String,System.String,System.Int32)">
             Return Type: void
            keyToMatch: PConstantString->char*
            valueToMatch: PConstantString->char*
            comparisonType: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_AddRequestLobbyListNumericalFilter(System.String,System.Int32,System.Int32)">
             Return Type: void
            keyToMatch: PConstantString->char*
            valueToMatch: s32->int32->int
            comparisonType: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_AddRequestLobbyListNearValueFilter(System.String,System.Int32)">
             Return Type: void
            keyToMatch: PConstantString->char*
            valueToBeCloseTo: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_AddRequestLobbyListFilterSlotsAvailable(System.Int32)">
             Return Type: void
            SlotsAvailable: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_AddRequestLobbyListDistanceFilter(System.Int32)">
             Return Type: void
            lobbyDistanceFilter: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_AddRequestLobbyListResultCountFilter(System.Int32)">
             Return Type: void
            maxResults: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_AddRequestLobbyListCompatibleMembersFilter(System.UInt64)">
             Return Type: void
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_GetLobbyByIndex(System.Int32)">
             Return Type: SteamID->u64->uint64->unsigned __int64
            lobby: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_CreateLobby(System.Int32,System.Int32)">
             Return Type: void
            lobbyType: Enum->s32->int32->int
            maxMembers: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_JoinLobby(System.UInt64)">
             Return Type: void
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_LeaveLobby(System.UInt64)">
             Return Type: void
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_InviteUserToLobby(System.UInt64,System.UInt64)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            steamIDInvitee: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_GetNumLobbyMembers(System.UInt64)">
             Return Type: s32->int32->int
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_GetLobbyMemberByIndex(System.UInt64,System.Int32)">
             Return Type: SteamID->u64->uint64->unsigned __int64
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            member: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_GetLobbyData(System.UInt64,System.String)">
             Return Type: PConstantString->char*
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            key: PConstantString->char*
        </member>
        <member name="M:NativeMethods.MatchMaking_SetLobbyData(System.UInt64,System.String,System.String)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            key: PConstantString->char*
            value: PConstantString->char*
        </member>
        <member name="M:NativeMethods.MatchMaking_GetLobbyDataCount(System.UInt64)">
             Return Type: s32->int32->int
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_GetLobbyDataByIndex(System.UInt64,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            lobbyData: s32->int32->int
            key: PString->char*
            keyBufferSize: s32->int32->int
            value: PString->char*
            valueBufferSize: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_DeleteLobbyData(System.UInt64,System.String)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            key: PConstantString->char*
        </member>
        <member name="M:NativeMethods.MatchMaking_GetLobbyMemberData(System.UInt64,System.UInt64,System.String)">
             Return Type: PConstantString->char*
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            SteamIDUser: SteamID->u64->uint64->unsigned __int64
            key: PConstantString->char*
        </member>
        <member name="M:NativeMethods.MatchMaking_SetLobbyMemberData(System.UInt64,System.String,System.String)">
             Return Type: void
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            key: PConstantString->char*
            value: PConstantString->char*
        </member>
        <member name="M:NativeMethods.MatchMaking_SendLobbyChatMsg(System.UInt64,System.IntPtr,System.Int32)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            msg: PConstantDataPointer->void*
            cubMsg: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_GetLobbyChatEntry(System.UInt64,System.Int32,System.UInt64@,System.IntPtr,System.Int32,System.Int32@)">
             Return Type: s32->int32->int
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            chatID: s32->int32->int
            steamIDUser: SteamID*
            data: PDataPointer->void*
            dataBufferSize: s32->int32->int
            chatEntryType: Enum*
        </member>
        <member name="M:NativeMethods.MatchMaking_RequestLobbyData(System.UInt64)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_SetLobbyGameServer(System.UInt64,System.UInt32,System.UInt16,System.UInt64)">
             Return Type: void
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            gameServerIP: u32->uint32->unsigned int
            gameServerPort: u16->uint16->unsigned short
            steamIDGameServer: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_GetLobbyGameServer(System.UInt64,System.UInt32@,System.UInt16@,System.UInt64@)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            gameServerIP: u32*
            gameServerPort: u16*
            steamIDGameServer: SteamID*
        </member>
        <member name="M:NativeMethods.MatchMaking_SetLobbyMemberLimit(System.UInt64,System.Int32)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            maxMembers: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_GetLobbyMemberLimit(System.UInt64)">
             Return Type: s32->int32->int
            steamIDlobby: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_SetLobbyType(System.UInt64,System.Int32)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            lobbyType: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchMaking_SetLobbyJoinable(System.UInt64,System.Boolean)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            lobbyJoinable: boolean
        </member>
        <member name="M:NativeMethods.MatchMaking_GetLobbyOwner(System.UInt64)">
             Return Type: SteamID->u64->uint64->unsigned __int64
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_SetLobbyOwner(System.UInt64,System.UInt64)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            steamIDNewOwner: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchMaking_SetLinkedLobby(System.UInt64,System.UInt64)">
             Return Type: boolean
            steamIDLobby: SteamID->u64->uint64->unsigned __int64
            steamIDLobbyDependent: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.MatchmakingServerNetworkAddress_GetConnectionString(System.IntPtr)">
             Return Type: PConstantAnsiString->char*
            instance: PConstantDataPointer->void*
        </member>
        <member name="M:NativeMethods.MatchmakingServerNetworkAddress_GetQueryString(System.IntPtr)">
             Return Type: PConstantAnsiString->char*
            instance: PConstantDataPointer->void*
        </member>
        <member name="M:NativeMethods.MatchmakingServers_RequestInternetServerList(System.UInt32,System.IntPtr,System.UInt32,System.UInt32)">
             Return Type: ServerListRequest->uptr->uintp->unsigned int
            appId: u32->uint32->unsigned int
            filters: PDataPointer->void*
            filterCount: u32->uint32->unsigned int
            requestServersResponse: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_RequestLANServerList(System.UInt32,System.UInt32)">
             Return Type: ServerListRequest->uptr->uintp->unsigned int
            appId: u32->uint32->unsigned int
            requestServersResponse: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_RequestFriendsServerList(System.UInt32,System.IntPtr,System.UInt32,System.UInt32)">
             Return Type: ServerListRequest->uptr->uintp->unsigned int
            appId: u32->uint32->unsigned int
            filters: PDataPointer->void*
            filtersCount: u32->uint32->unsigned int
            requestServersResponse: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_RequestFavoritesServerList(System.UInt32,System.IntPtr,System.UInt32,System.UInt32)">
             Return Type: ServerListRequest->uptr->uintp->unsigned int
            appId: u32->uint32->unsigned int
            filters: PDataPointer->void*
            filterCount: u32->uint32->unsigned int
            requestServersResponse: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_RequestHistoryServerList(System.UInt32,System.IntPtr,System.UInt32,System.UInt32)">
             Return Type: ServerListRequest->uptr->uintp->unsigned int
            appId: u32->uint32->unsigned int
            filters: PDataPointer->void*
            filterCount: u32->uint32->unsigned int
            requestServersResponse: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_RequestSpectatorServerList(System.UInt32,System.IntPtr,System.UInt32,System.UInt32)">
             Return Type: ServerListRequest->uptr->uintp->unsigned int
            appId: u32->uint32->unsigned int
            filters: PDataPointer->void*
            filterCount: u32->uint32->unsigned int
            requestServersResponse: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_ReleaseRequest(System.UInt32)">
             Return Type: void
            request: ServerListRequest->uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_GetServerDetails(System.UInt32,System.Int32)">
             Return Type: PDataPointer->void*
            request: ServerListRequest->uptr->uintp->unsigned int
            server: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_GetGameServerItemSize">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_CancelQuery(System.UInt32)">
             Return Type: void
            request: ServerListRequest->uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_RefreshQuery(System.UInt32)">
             Return Type: void
            request: ServerListRequest->uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_IsRefreshing(System.UInt32)">
             Return Type: boolean
            request: ServerListRequest->uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_GetServerCount(System.UInt32)">
             Return Type: s32->int32->int
            request: ServerListRequest->uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_RefreshServer(System.UInt32,System.Int32)">
             Return Type: void
            request: ServerListRequest->uptr->uintp->unsigned int
            server: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_PingServer(System.UInt32,System.UInt16,System.UInt32)">
             Return Type: ServerQuery->s32->int32->int
            ip: u32->uint32->unsigned int
            port: u16->uint16->unsigned short
            requestServersResponse: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_PlayerDetails(System.UInt32,System.UInt16,System.UInt32)">
             Return Type: ServerQuery->s32->int32->int
            ip: u32->uint32->unsigned int
            port: u16->uint16->unsigned short
            requestServersResponse: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_ServerRules(System.UInt32,System.UInt16,System.UInt32)">
             Return Type: ServerQuery->s32->int32->int
            ip: u32->uint32->unsigned int
            port: u16->uint16->unsigned short
            requestServersResponse: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServers_CancelServerQuery(System.Int32)">
             Return Type: void
            serverQuery: s32->int32->int
        </member>
        <member name="M:NativeMethods.MatchmakingServerListResponse_CreateObject">
            Return Type: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServerListResponse_DestroyObject(System.UInt32)">
             Return Type: void
            obj: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingServerListResponse_RegisterCallbacks(MatchmakingServerListResponse_ServerRespondedCallback,MatchmakingServerListResponse_ServerFailedToRespond,MatchmakingServerListResponse_RefreshComplete)">
             Return Type: void
            serverResponded: MatchmakingServerListResponse_ServerRespondedCallback
            serverFailedToRespond: MatchmakingServerListResponse_ServerFailedToRespond
            refreshComplete: MatchmakingServerListResponse_RefreshComplete
        </member>
        <member name="M:NativeMethods.MatchmakingServerListResponse_RemoveCallbacks">
            Return Type: void
        </member>
        <member name="M:NativeMethods.MatchmakingPingResponse_CreateObject">
            Return Type: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingPingResponse_DestroyObject(System.UInt32)">
             Return Type: void
            obj: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingPingResponse_RegisterCallbacks(MatchmakingPingResponse_ServerRespondedCallback,MatchmakingPingResponse_ServerFailedToRespond)">
             Return Type: void
            serverResponded: MatchmakingPingResponse_ServerRespondedCallback
            serverFailedToRespond: MatchmakingPingResponse_ServerFailedToRespond
        </member>
        <member name="M:NativeMethods.MatchmakingPingResponse_RemoveCallbacks">
            Return Type: void
        </member>
        <member name="M:NativeMethods.MatchmakingPlayersResponse_CreateObject">
            Return Type: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingPlayersResponse_DestroyObject(System.UInt32)">
             Return Type: void
            obj: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingPlayersResponse_RegisterCallbacks(MatchmakingPlayersResponse_AddPlayerToList,MatchmakingPlayersResponse_PlayersFailedToRespond,MatchmakingPlayersResponse_PlayersRefreshComplete)">
             Return Type: void
            addPlayerToList: MatchmakingPlayersResponse_AddPlayerToList
            playersFailedToRespond: MatchmakingPlayersResponse_PlayersFailedToRespond
            playersRefreshComplete: MatchmakingPlayersResponse_PlayersRefreshComplete
        </member>
        <member name="M:NativeMethods.MatchmakingPlayersResponse_RemoveCallbacks">
            Return Type: void
        </member>
        <member name="M:NativeMethods.MatchmakingRulesResponse_CreateObject">
            Return Type: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingRulesResponse_DestroyObject(System.UInt32)">
             Return Type: void
            obj: uptr->uintp->unsigned int
        </member>
        <member name="M:NativeMethods.MatchmakingRulesResponse_RegisterCallbacks(MatchmakingRulesResponse_RulesResponded,MatchmakingRulesResponse_RulesFailedToRespond,MatchmakingRulesResponse_RulesRefreshComplete)">
             Return Type: void
            rulesResponded: MatchmakingRulesResponse_RulesResponded
            rulesFailedToRespond: MatchmakingRulesResponse_RulesFailedToRespond
            rulesRefreshComplete: MatchmakingRulesResponse_RulesRefreshComplete
        </member>
        <member name="M:NativeMethods.MatchmakingRulesResponse_RemoveCallbacks">
            Return Type: void
        </member>
        <member name="M:NativeMethods.GameServer_InitGameServer(System.UInt32,System.UInt16,System.UInt16,System.UInt32,System.UInt32,System.String)">
             Return Type: boolean
            ip: u32->uint32->unsigned int
            gamePort: u16->uint16->unsigned short
            queryPort: u16->uint16->unsigned short
            flags: u32->uint32->unsigned int
            gameAppId: AppID->u32->uint32->unsigned int
            versionString: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_SetProduct(System.String)">
             Return Type: void
            product: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_SetGameDescription(System.String)">
             Return Type: void
            gameDescription: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_SetModDir(System.String)">
             Return Type: void
            modDir: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_SetDedicatedServer(System.Boolean)">
             Return Type: void
            dedicated: boolean
        </member>
        <member name="M:NativeMethods.GameServer_LogOn(System.String,System.String)">
             Return Type: void
            accountName: PConstantString->char*
            password: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_LogOnAnonymous">
            Return Type: void
        </member>
        <member name="M:NativeMethods.GameServer_LogOff">
            Return Type: void
        </member>
        <member name="M:NativeMethods.GameServer_LoggedOn">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.GameServer_Secure">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.GameServer_GetSteamID">
            Return Type: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.GameServer_WasRestartRequested">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.GameServer_SetMaxPlayerCount(System.Int32)">
             Return Type: void
            playersMax: s32->int32->int
        </member>
        <member name="M:NativeMethods.GameServer_SetBotPlayerCount(System.Int32)">
             Return Type: void
            botplayers: s32->int32->int
        </member>
        <member name="M:NativeMethods.GameServer_SetServerName(System.String)">
             Return Type: void
            serverName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_SetMapName(System.String)">
             Return Type: void
            mapName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_SetPasswordProtected(System.Boolean)">
             Return Type: void
            passwordProtected: boolean
        </member>
        <member name="M:NativeMethods.GameServer_SetSpectatorPort(System.UInt16)">
             Return Type: void
            spectatorPort: u16->uint16->unsigned short
        </member>
        <member name="M:NativeMethods.GameServer_SetSpectatorServerName(System.String)">
             Return Type: void
            spectatorServerName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_ClearAllKeyValues">
            Return Type: void
        </member>
        <member name="M:NativeMethods.GameServer_SetKeyValue(System.String,System.String)">
             Return Type: void
            key: PConstantString->char*
            value: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_SetGameTags(System.String)">
             Return Type: void
            gameTags: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_SetGameData(System.String)">
             Return Type: void
            gameData: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_SetRegion(System.String)">
             Return Type: void
            region: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServer_SendUserConnectAndAuthenticate(System.UInt32,System.IntPtr,System.UInt32,System.UInt64@)">
             Return Type: boolean
            ipClient: u32->uint32->unsigned int
            authBlob: PConstantDataPointer->void*
            authBlobSize: u32->uint32->unsigned int
            steamIDUser: SteamID*
        </member>
        <member name="M:NativeMethods.GameServer_CreateUnauthenticatedUserConnection">
            Return Type: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.GameServer_SendUserDisconnect(System.UInt64)">
             Return Type: void
            steamIDUser: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.GameServer_UpdateUserData(System.UInt64,System.String,System.UInt32)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            playerName: PConstantString->char*
            core: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.GameServer_GetAuthSessionTicket(System.IntPtr,System.Int32,System.UInt32@)">
             Return Type: AuthTicket->u32->uint32->unsigned int
            ticket: PDataPointer->void*
            maxTicket: s32->int32->int
            ticketSize: u32*
        </member>
        <member name="M:NativeMethods.GameServer_BeginAuthSession(System.IntPtr,System.Int32,System.UInt64)">
             Return Type: Enum->s32->int32->int
            authTicket: PConstantDataPointer->void*
            authTicketSize: s32->int32->int
            steamID: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.GameServer_EndAuthSession(System.UInt64)">
             Return Type: void
            steamID: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.GameServer_CancelAuthTicket(System.UInt32)">
             Return Type: void
            authTicket: AuthTicket->u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.GameServer_UserHasLicenseForApp(System.UInt64,System.UInt32)">
             Return Type: Enum->s32->int32->int
            steamID: SteamID->u64->uint64->unsigned __int64
            appID: AppID->u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.GameServer_RequestUserGroupStatus(System.UInt64,System.UInt64)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            steamIDGroup: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.GameServer_GetGameplayStats">
            Return Type: void
        </member>
        <member name="M:NativeMethods.GameServer_GetServerReputation">
            Return Type: void
        </member>
        <member name="M:NativeMethods.GameServer_GetPublicIP">
            Return Type: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.GameServer_HandleIncomingPacket(System.IntPtr,System.Int32,System.UInt32,System.UInt16)">
             Return Type: boolean
            data: PConstantDataPointer->void*
            dataSize: s32->int32->int
            ip: u32->uint32->unsigned int
            srcPort: u16->uint16->unsigned short
        </member>
        <member name="M:NativeMethods.GameServer_GetNextOutgoingPacket(System.IntPtr,System.Int32,System.UInt32@,System.UInt16@)">
             Return Type: s32->int32->int
            out: PDataPointer->void*
            maxOut: s32->int32->int
            netAdr: u32*
            port: u16*
        </member>
        <member name="M:NativeMethods.GameServer_EnableHeartbeats(System.Boolean)">
             Return Type: void
            active: boolean
        </member>
        <member name="M:NativeMethods.GameServer_SetHeartbeatInterval(System.Int32)">
             Return Type: void
            heartbeatInterval: s32->int32->int
        </member>
        <member name="M:NativeMethods.GameServer_ForceHeartbeat">
            Return Type: void
        </member>
        <member name="M:NativeMethods.GameServer_AssociateWithClan(System.UInt64)">
             Return Type: void
            steamIDClan: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.GameServer_ComputeNewPlayerCompatibility(System.UInt64)">
             Return Type: void
            steamIDNewPlayer: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.GameServerStats_RequestUserStats(System.UInt64)">
             Return Type: void
            steamIDUser: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.GameServerStats_GetUserStatInt(System.UInt64,System.String,System.Int32@)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
            data: s32*
        </member>
        <member name="M:NativeMethods.GameServerStats_GetUserStatFloat(System.UInt64,System.String,System.Single@)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
            data: f32*
        </member>
        <member name="M:NativeMethods.GameServerStats_GetUserAchievement(System.UInt64,System.String,System.Boolean@)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
            achieved: boolean*
        </member>
        <member name="M:NativeMethods.GameServerStats_SetUserStatInt(System.UInt64,System.String,System.Int32)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
            data: s32->int32->int
        </member>
        <member name="M:NativeMethods.GameServerStats_SetUserStatFloat(System.UInt64,System.String,System.Single)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
            data: f32->float
        </member>
        <member name="M:NativeMethods.GameServerStats_UpdateUserAvgRateStat(System.UInt64,System.String,System.Single,System.Double)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
            countThisSession: f32->float
            sessionLength: f64->double
        </member>
        <member name="M:NativeMethods.GameServerStats_SetUserAchievement(System.UInt64,System.String)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServerStats_ClearUserAchievement(System.UInt64,System.String)">
             Return Type: boolean
            steamIDUser: SteamID->u64->uint64->unsigned __int64
            name: PConstantString->char*
        </member>
        <member name="M:NativeMethods.GameServerStats_StoreUserStats(System.UInt64)">
             Return Type: void
            steamIDUser: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Networking_SendP2PPacket(System.UInt64,System.IntPtr,System.UInt32,System.Int32,System.Int32)">
             Return Type: boolean
            steamIDRemote: SteamID->u64->uint64->unsigned __int64
            data: PConstantDataPointer->void*
            cubData: uint32->unsigned int
            p2pSendType: Enum->s32->int32->int
            channel: int
        </member>
        <member name="M:NativeMethods.Networking_SendP2PPacketOffset(System.UInt64,System.IntPtr,System.UInt32,System.UInt32,System.Int32,System.Int32)">
             Return Type: boolean
            steamIDRemote: SteamID->u64->uint64->unsigned __int64
            data: PConstantDataPointer->void*
            cubData: uint32->unsigned int
            dataOffset: uint32->unsigned int
            p2pSendType: Enum->s32->int32->int
            channel: int
        </member>
        <member name="M:NativeMethods.Networking_IsP2PPacketAvailable(System.UInt32@,System.Int32)">
             Return Type: boolean
            msgSize: u32*
            channel: int
        </member>
        <member name="M:NativeMethods.Networking_ReadP2PPacket(System.IntPtr,System.UInt32,System.UInt32@,System.UInt64@,System.Int32)">
             Return Type: boolean
            dest: PDataPointer->void*
            cubDest: u32->uint32->unsigned int
            msgSize: u32*
            steamIDRemote: SteamID*
            channel: int
        </member>
        <member name="M:NativeMethods.Networking_AcceptP2PSessionWithUser(System.UInt64)">
             Return Type: boolean
            steamIDRemote: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Networking_CloseP2PSessionWithUser(System.UInt64)">
             Return Type: boolean
            steamIDRemote: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Networking_CloseP2PChannelWithUser(System.UInt64,System.Int32)">
             Return Type: boolean
            steamIDRemote: SteamID->u64->uint64->unsigned __int64
            channel: int
        </member>
        <member name="M:NativeMethods.Networking_GetP2PSessionState(System.UInt64,System.IntPtr)">
             Return Type: boolean
            steamIDRemote: SteamID->u64->uint64->unsigned __int64
            connectionState: PDataPointer->void*
        </member>
        <member name="M:NativeMethods.Networking_AllowP2PPacketRelay(System.Boolean)">
             Return Type: boolean
            allow: boolean
        </member>
        <member name="M:NativeMethods.Networking_CreateListenSocket(System.Int32,System.UInt32,System.UInt16,System.Boolean)">
             Return Type: NetListenSocket->u32->uint32->unsigned int
            virtualP2PPort: int
            ip: u32->uint32->unsigned int
            port: u16->uint16->unsigned short
            allowUseOfPacketRelay: boolean
        </member>
        <member name="M:NativeMethods.Networking_CreateP2PConnectionSocket(System.UInt64,System.Int32,System.Int32,System.Boolean)">
             Return Type: NetSocket->u32->uint32->unsigned int
            steamIDTarget: SteamID->u64->uint64->unsigned __int64
            virtualPort: int
            timeoutSec: int
            allowUseOfPacketRelay: boolean
        </member>
        <member name="M:NativeMethods.Networking_CreateConnectionSocket(System.UInt32,System.UInt16,System.Int32)">
             Return Type: NetSocket->u32->uint32->unsigned int
            ip: u32->uint32->unsigned int
            port: u16->uint16->unsigned short
            timeoutSec: int
        </member>
        <member name="M:NativeMethods.Networking_DestroySocket(System.UInt32,System.Boolean)">
             Return Type: boolean
            socket: NetSocket->u32->uint32->unsigned int
            notifyRemoteEnd: boolean
        </member>
        <member name="M:NativeMethods.Networking_DestroyListenSocket(System.UInt32,System.Boolean)">
             Return Type: boolean
            socket: NetListenSocket->u32->uint32->unsigned int
            notifyRemoteEnd: boolean
        </member>
        <member name="M:NativeMethods.Networking_SendDataOnSocket(System.UInt32,System.IntPtr,System.UInt32,System.Boolean)">
             Return Type: boolean
            socket: NetSocket->u32->uint32->unsigned int
            data: PDataPointer->void*
            cubData: u32->uint32->unsigned int
            reliable: boolean
        </member>
        <member name="M:NativeMethods.Networking_IsDataAvailableOnSocket(System.UInt32,System.UInt32@)">
             Return Type: boolean
            socket: NetSocket->u32->uint32->unsigned int
            msgSize: u32*
        </member>
        <member name="M:NativeMethods.Networking_RetrieveDataFromSocket(System.UInt32,System.IntPtr,System.UInt32,System.UInt32@)">
             Return Type: boolean
            socket: NetSocket->u32->uint32->unsigned int
            dest: void*
            cubDest: u32->uint32->unsigned int
            msgSize: u32*
        </member>
        <member name="M:NativeMethods.Networking_IsDataAvailable(System.UInt32,System.UInt32@,System.UInt32@)">
             Return Type: boolean
            listenSocket: NetListenSocket->u32->uint32->unsigned int
            msgSize: u32*
            socket: NetSocket*
        </member>
        <member name="M:NativeMethods.Networking_RetrieveData(System.UInt32,System.IntPtr,System.UInt32,System.UInt32@,System.UInt32@)">
             Return Type: boolean
            listenSocket: NetListenSocket->u32->uint32->unsigned int
            pubDest: void*
            cubDest: u32->uint32->unsigned int
            msgSize: u32*
            socket: NetSocket*
        </member>
        <member name="M:NativeMethods.Networking_GetSocketInfo(System.UInt32,System.UInt64@,System.Int32@,System.UInt32@,System.UInt16@)">
             Return Type: boolean
            socket: NetSocket->u32->uint32->unsigned int
            steamIDRemote: SteamID*
            socketStatus: Enum*
            ipRemote: u32*
            portRemote: u16*
        </member>
        <member name="M:NativeMethods.Networking_GetListenSocketInfo(System.UInt32,System.UInt32@,System.UInt16@)">
             Return Type: boolean
            listenSocket: NetListenSocket->u32->uint32->unsigned int
            ip: u32*
            port: u16*
        </member>
        <member name="M:NativeMethods.Networking_GetSocketConnectionType(System.UInt32)">
             Return Type: Enum->s32->int32->int
            socket: NetSocket->u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Networking_GetMaxPacketSize(System.UInt32)">
             Return Type: int
            socket: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Networking_GetP2PSessionStateSize">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.ServicesGameServer_GetInterfaceVersion">
            Return Type: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.ServicesGameServer_GetErrorCode">
            Return Type: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.ServicesGameServer_Startup(System.UInt32,System.UInt32,System.UInt16,System.UInt16,System.UInt16,System.Int32,System.String)">
             Return Type: boolean
            interfaceVersion: u32->uint32->unsigned int
            ip: u32->uint32->unsigned int
            steamPort: u16->uint16->unsigned short
            gamePort: u16->uint16->unsigned short
            queryPort: u16->uint16->unsigned short
            serverMode: Enum->s32->int32->int
            versionString: PConstantString->char*
        </member>
        <member name="M:NativeMethods.ServicesGameServer_Shutdown">
            Return Type: void
        </member>
        <member name="M:NativeMethods.ServicesGameServer_GetSteamLoadStatus">
            Return Type: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.ServicesGameServer_HandleCallbacks">
            Return Type: void
        </member>
        <member name="M:NativeMethods.ServicesGameServer_RegisterManagedCallbacks(ManagedCallback,ManagedResultCallback)">
             Return Type: void
            callback: ManagedCallback
            resultCallback: ManagedResultCallback
        </member>
        <member name="M:NativeMethods.ServicesGameServer_RemoveManagedCallbacks">
            Return Type: void
        </member>
        <member name="M:NativeMethods.Utils_GetSecondsSinceAppActive">
            Return Type: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Utils_GetSecondsSinceComputerActive">
            Return Type: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Utils_GetConnectedUniverse">
            Return Type: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Utils_GetServerRealTime">
            Return Type: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Utils_GetIPCountry">
            Return Type: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Utils_GetImageSize(System.Int32,System.UInt32@,System.UInt32@)">
             Return Type: boolean
            iImage: int
            pnWidth: uint32*
            pnHeightr: uint32*
        </member>
        <member name="M:NativeMethods.Utils_GetImageRGBA(System.Int32,System.IntPtr,System.Int32)">
             Return Type: boolean
            iImage: int
            pubDest: uint8*
            nDestBufferSize: int
        </member>
        <member name="M:NativeMethods.Utils_GetCSERIPPort(System.UInt32@,System.UInt16@)">
             Return Type: boolean
            unIP: u32*
            usPort: u16*
        </member>
        <member name="M:NativeMethods.Utils_GetCurrentBatteryPower">
            Return Type: u8->uint8->unsigned char
        </member>
        <member name="M:NativeMethods.Utils_GetAppID">
            Return Type: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Utils_SetOverlayNotificationPosition(System.Int32)">
            Return Type: void
            eNotificationPosition: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.Utils_IsAPICallCompleted(System.UInt64,System.Boolean@)">
             Return Type: boolean
            hSteamAPICall: SteamAPICall_t->uint64->unsigned __int64
            pbFailed: boolean*
        </member>
        <member name="M:NativeMethods.Utils_GetAPICallResult(System.UInt64,System.IntPtr,System.Int32,System.Int32,System.Boolean@)">
             Return Type: boolean
            hSteamAPICall: SteamAPICall_t->uint64->unsigned __int64
            pCallback: void*
            cubCallback: int
            iCallbackExpected: int
            pbFailed: boolean*
        </member>
        <member name="M:NativeMethods.Utils_RunFrame">
            Return Type: void
        </member>
        <member name="M:NativeMethods.Utils_GetIPCCallCount">
            Return Type: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Utils_IsOverlayEnabled">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Utils_OverlayNeedsPresent">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Utils_ShowGamepadTextInput(System.Int32,System.Int32,System.String,System.UInt32)">
            Return Type: boolean
            inputMode: Enum->s32->int32->int
            lineInputMode: Enum->s32->int32->int
            description: PConstantString->char*
            charMax: uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Utils_GetEnteredGamepadTextLength">
            Return Type: uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Utils_GetEnteredGamepadTextInput(System.IntPtr,System.UInt32)">
             Return Type: boolean
            pchText: PString->char*
            cchText: uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Utils_IsSteamRunningInVR">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Apps_IsSubscribed">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Apps_IsLowViolence">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Apps_IsCybercafe">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Apps_IsVACBanned">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Apps_GetCurrentGameLanguage">
            Return Type: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Apps_GetAvailableGameLanguages">
            Return Type: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Apps_IsSubscribedApp(System.UInt32)">
            Return Type: boolean
            appID: AppID->u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Apps_IsDlcInstalled(System.UInt32)">
            Return Type: boolean
            appID: AppID->u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Apps_GetEarliestPurchaseUnixTime(System.UInt32)">
            Return Type: u32->uint32->unsigned int
            appID: AppID->u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Apps_IsSubscribedFromFreeWeekend">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.Apps_GetDLCCount">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.Apps_GetDLCDataByIndex(System.Int32,System.UInt32@,System.Boolean@,System.IntPtr,System.Int32)">
            Return Type: boolean
            iDLC: s32->int32->int
            pAppID: u32*
            pbAvailable: boolean*
            pchName: PString->char*
            cchnameBufferSize: s32->int32->int
        </member>
        <member name="M:NativeMethods.Apps_InstallDLC(System.UInt32)">
            Return Type: void
            appID: AppID->u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Apps_UninstallDLC(System.UInt32)">
            Return Type: void
            appID: AppID->u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Apps_RequestAppProofOfPurchaseKey(System.UInt32)">
            Return Type: void
            AppID: AppID->u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Apps_GetCurrentBetaName(System.IntPtr,System.Int32)">
            Return Type: boolean
            pchName: PString->char*
            cchNameBufferSize: s32->int32->int
        </member>
        <member name="M:NativeMethods.Apps_MarkContentCorrupt(System.Boolean)">
            Return Type: boolean
            bMissingFilesOnly: boolean
        </member>
        <member name="M:NativeMethods.Apps_GetInstalledDepots(System.UInt32,System.UInt32@,System.UInt32)">
            Return Type: u32->uint32->unsigned int
            appID: AppID->u32->uint32->unsigned int
            pvecDepots: u32*
            cMaxDepots: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Apps_GetAppOwner">
            Return Type: SteamID->u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Apps_GetLaunchQueryParam(System.String)">
            Return Type: PConstantString->char*
            Key: PConstantString->char*
        </member>
        <member name="M:NativeMethods.HTTP_CreateHTTPRequest(System.Int32,System.IntPtr)">
            Return Type: u32->uint32->unsigned int
            eHTTPRequestMethod: Enum->s32->int32->int
            pchAbsoluteURL: PConstantUtf8String->void*
        </member>
        <member name="M:NativeMethods.HTTP_SetHTTPRequestContextValue(System.UInt32,System.UInt64)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            ulContextValue: u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.HTTP_SetHTTPRequestNetworkActivityTimeout(System.UInt32,System.UInt32)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            unTimeoutSeconds: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.HTTP_SetHTTPRequestHeaderValue(System.UInt32,System.IntPtr,System.IntPtr)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            pchHeaderName: PConstantUtf8String->void*
            pchHeaderValue: PConstantUtf8String->void*
        </member>
        <member name="M:NativeMethods.HTTP_SetHTTPRequestGetOrPostParameter(System.UInt32,System.IntPtr,System.IntPtr)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            pchParamName: PConstantUtf8String->void*
            pchParamValue: PConstantUtf8String->void*
        </member>
        <member name="M:NativeMethods.HTTP_SendHTTPRequest(System.UInt32,System.UInt64@)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            pCallhandle: u64*
        </member>
        <member name="M:NativeMethods.HTTP_SendHTTPRequestAndStreamResponse(System.UInt32,System.UInt64@)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            pCallhandle: u64*
        </member>
        <member name="M:NativeMethods.HTTP_DeferHTTPRequest(System.UInt32)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.HTTP_PrioritizeHTTPRequest(System.UInt32)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.HTTP_GetHTTPResponseHeaderSize(System.UInt32,System.IntPtr,System.UInt32@)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            pchHeaderName: PConstantUtf8String->void*
            unResponseHeaderSize: u32*
        </member>
        <member name="M:NativeMethods.HTTP_GetHTTPResponseHeaderValue(System.UInt32,System.IntPtr,System.IntPtr,System.UInt32)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            pchHeaderName: PConstantUtf8String->void*
            pHeaderValueBuffer: uint8*
            unBufferSize: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.HTTP_GetHTTPResponseBodySize(System.UInt32,System.UInt32@)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            unBodySize: u32*
        </member>
        <member name="M:NativeMethods.HTTP_GetHTTPResponseBodyData(System.UInt32,System.IntPtr,System.UInt32)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            PBodyDataBuffer: uint8*
            unBufferSize: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.HTTP_GetHTTPStreamingResponseBodyData(System.UInt32,System.UInt32,System.IntPtr,System.UInt32)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            cOffset: u32->uint32->unsigned int
            pBodyDataBuffer: uint8*
            unBufferSize: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.HTTP_ReleaseHTTPRequest(System.UInt32)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.HTTP_GetHTTPDownloadProgressPct(System.UInt32,System.Single@)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            pflPercentOut: 
        </member>
        <member name="M:NativeMethods.HTTP_SetHTTPRequestRawPostBody(System.UInt32,System.IntPtr,System.IntPtr,System.UInt32)">
            Return Type: boolean
            hRequest: u32->uint32->unsigned int
            pchContentType: PConstantUtf8String->void*
            pubBody: uint8*
            unBodyLen: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.Screenshots_WriteScreenshot(System.IntPtr,System.UInt32,System.Int32,System.Int32)">
            Return Type: u32->uint32->unsigned int
            pubRGB: PDataPointer->void*
            cubRGB: u32->uint32->unsigned int
            nWidth: s32->int32->int
            nHeight: s32->int32->int
        </member>
        <member name="M:NativeMethods.Screenshots_AddScreenshotToLibrary(System.String,System.String,System.Int32,System.Int32)">
            Return Type: u32->uint32->unsigned int
            pchFilename: PConstantString->char*
            pchThumbnailFileName: PConstantString->char*
            nWidth: s32->int32->int
            nHeight: s32->int32->int
        </member>
        <member name="M:NativeMethods.Screenshots_TriggerScreenshot">
            Return Type: void
        </member>
        <member name="M:NativeMethods.Screenshots_HookScreenshots(System.Boolean)">
            Return Type: void
            bHook: boolean
        </member>
        <member name="M:NativeMethods.Screenshots_SetLocation(System.UInt32,System.String)">
            Return Type: boolean
            hScreenshot: u32->uint32->unsigned int
            pchLocation: PConstantString->char*
        </member>
        <member name="M:NativeMethods.Screenshots_TagUser(System.UInt32,System.UInt64)">
            Return Type: boolean
            hScreenshot: u32->uint32->unsigned int
            steamID: u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.Screenshots_TagPublishedFile(System.UInt32,System.UInt64)">
            Return Type: boolean
            hScreenshot: u32->uint32->unsigned int
            unPublishedFileID: u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.UGC_CreateQueryUserUGCRequest(System.UInt32,System.Int32,System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt32)">
            Return Type: u64->uint64->unsigned __int64
            AccountID: u32->uint32->unsigned int
            eListType: Enum->s32->int32->int
            eMatchingUGCType: Enum->s32->int32->int
            eSortOrder: Enum->s32->int32->int
            nCreatorAppID: AppID->u32->uint32->unsigned int
            nConsumerAppID: AppID->u32->uint32->unsigned int
            unPage: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.UGC_CreateQueryAllUGCRequest(System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt32)">
            Return Type: u64->uint64->unsigned __int64
            eQueryType: Enum->s32->int32->int
            eMatchingeMatchingUGCTypeFileType: Enum->s32->int32->int
            nCreatorAppID: AppID->u32->uint32->unsigned int
            nConsumerAppID: AppID->u32->uint32->unsigned int
            unPage: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.UGC_SendQueryUGCRequest(System.UInt64)">
            Return Type: void
            handle: u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.UGC_GetQueryUGCResult(System.UInt64,System.UInt32,System.IntPtr)">
            Return Type: boolean
            handle: u64->uint64->unsigned __int64
            index: u32->uint32->unsigned int
            pubRGB: PDataPointer->void*
        </member>
        <member name="M:NativeMethods.UGC_ReleaseQueryUGCRequest(System.UInt64)">
            Return Type: boolean
            handle: u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.UGC_AddRequiredTag(System.UInt64,System.String)">
            Return Type: boolean
            handle: u64->uint64->unsigned __int64
            pTagName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.UGC_AddExcludedTag(System.UInt64,System.String)">
            Return Type: boolean
            handle: u64->uint64->unsigned __int64
            pTagName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.UGC_SetReturnLongDescription(System.UInt64,System.Boolean)">
            Return Type: boolean
            handle: u64->uint64->unsigned __int64
            bReturnLongDescription: boolean
        </member>
        <member name="M:NativeMethods.UGC_SetReturnTotalOnly(System.UInt64,System.Boolean)">
            Return Type: boolean
            handle: u64->uint64->unsigned __int64
            bReturnTotalOnly: boolean
        </member>
        <member name="M:NativeMethods.UGC_SetCloudFileNameFilter(System.UInt64,System.String)">
            Return Type: boolean
            handle: u64->uint64->unsigned __int64
            pMatchCloudFileName: PConstantString->char*
        </member>
        <member name="M:NativeMethods.UGC_SetMatchAnyTag(System.UInt64,System.Boolean)">
            Return Type: boolean
            handle: u64->uint64->unsigned __int64
            bMatchAnyTag: boolean
        </member>
        <member name="M:NativeMethods.UGC_SetSearchText(System.UInt64,System.String)">
            Return Type: boolean
            handle: u64->uint64->unsigned __int64
            pSearchString: PConstantString->char*
        </member>
        <member name="M:NativeMethods.UGC_SetRankedByTrendDays(System.UInt64,System.UInt32)">
            Return Type: boolean
            handle: u64->uint64->unsigned __int64
            unDays: u32->uint32->unsigned int
        </member>
        <member name="M:NativeMethods.UGC_RequestUGCDetails(System.UInt64)">
            Return Type: void
            nPublishedFileID: u64->uint64->unsigned __int64
        </member>
        <member name="M:NativeMethods.SteamController_Init(System.String)">
            Return Type: boolean
            absolutPathToControllerConfigVDF: PConstantString->char*
        </member>
        <member name="M:NativeMethods.SteamController_Shutdown">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.SteamController_RunFrame">
            Return Type: void
        </member>
        <member name="M:NativeMethods.SteamController_GetControllerState(System.UInt32,System.IntPtr)">
            Return Type: boolean
            controllerIndex: u32->uint32->unsigned int
            state: PDataPointer->void*
        </member>
        <member name="M:NativeMethods.SteamController_TriggerHapticPulse(System.UInt32,System.Int32,System.UInt16)">
            Return Type: void
            controllerIndex: u32->uint32->unsigned int
            targetPad: Enum->s32->int32->int
            durationMicroSec: u16->uint16->unsigned short
        </member>
        <member name="M:NativeMethods.SteamController_SetOverrideMode(System.String)">
            Return Type: void
            mode: PConstantString->char*
        </member>
        <member name="M:NativeMethods.VR_Init">
            Return Type: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.VR_Shutdown">
            Return Type: void
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetWindowBounds(System.Int32@,System.Int32@,System.UInt32@,System.UInt32@)">
            Return Type: boolean
            X: s32*
            Y: s32*
            Width: u32*
            Height: u32*
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetRecommendedRenderTargetSize(System.UInt32@,System.UInt32@)">
            Return Type: void
            Width: u32*
            Height: u32*
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetEyeOutputViewport(System.Int32,System.Int32,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            Return Type: void
            Eye: Enum->s32->int32->int
            APIType: Enum->s32->int32->int
            X: u32*
            Y: u32*
            Width: u32*
            Height: u32*
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetProjectionMatrix(System.Int32,System.Single,System.Single,System.Int32)">
            Return Type: PDataPointer->void*
            Eye: Enum->s32->int32->int
            NearZ: f32->float
            FarZ: f32->float
            ProjType: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetProjectionRaw(System.Int32,System.Single@,System.Single@,System.Single@,System.Single@)">
            Return Type: void
            Eye: Enum->s32->int32->int
            Left: f32*
            Right: f32*
            Top: f32*
            Bottom: f32*
        </member>
        <member name="M:NativeMethods.VR_Hmd_ComputeDistortion(System.Int32,System.Single,System.Single)">
            Return Type: PDataPointer->void*
            Eye: Enum->s32->int32->int
            U: f32->float
            V: f32->float
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetEyeMatrix(System.Int32)">
            Return Type: PDataPointer->void*
            Eye: Enum->s32->int32->int
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetViewMatrix(System.Single,System.IntPtr,System.IntPtr,System.Int32@)">
            Return Type: boolean
            SecondsFromNow: f32->float
            MatLeftView: PDataPointer->void*
            MatRightView: PDataPointer->void*
            MatLeftView: PDataPointer->void*
            Result: Enum*
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetD3D9AdapterIndex">
            Return Type: s32->int32->int
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetWorldFromHeadPose(System.Single,System.IntPtr,System.Int32@)">
            Return Type: boolean
            PredictSecondsFromNow: f32->float
            Pose: PDataPointer->void*
            Result: Enum*
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetLastWorldFromHeadPose(System.IntPtr)">
            Return Type: boolean
            Pose: PDataPointer->void*
        </member>
        <member name="M:NativeMethods.VR_Hmd_WillDriftInYaw">
            Return Type: boolean
        </member>
        <member name="M:NativeMethods.VR_Hmd_ZeroTracker">
            Return Type: void
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetDriverId(System.IntPtr,System.UInt32)">
            Return Type: u32->uint32->uint
            Buffer: PString->char*
            BufferLen: u32->uint32->uint
        </member>
        <member name="M:NativeMethods.VR_Hmd_GetDisplayId(System.IntPtr,System.UInt32)">
            Return Type: u32->uint32->uint
            Buffer: PString->char*
            BufferLen: u32->uint32->uint
        </member>
        <member name="M:ManagedSteam.Implementations.Cloud.Share(System.String)">
            <summary>
            Invokes CloudFileShareResult
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:ManagedSteam.Implementations.Cloud.UGCDownload(ManagedSteam.SteamTypes.UGCHandle,System.UInt32)">
            <summary>
            Invokes CloudDownloadUGCResult
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:ManagedSteam.Implementations.Cloud.GetUGCDetails(ManagedSteam.SteamTypes.UGCHandle,ManagedSteam.SteamTypes.AppID@,System.String@,System.Int32@,ManagedSteam.SteamTypes.SteamID@)">
            <summary>
            
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Cloud.CloudFileShareResult">
            <summary>
            Invoked by Share()
            </summary>
        </member>
        <member name="E:ManagedSteam.Implementations.Cloud.CloudDownloadUGCResult">
            <summary>
            Invoked by UGCDownload()
            </summary>
        </member>
        <member name="T:ManagedSteam.Steam">
            <summary>
            The main class.
            This is the primary interface point between .NET code and the native C++ code.
            Use Initialize() to start the API.
            </summary>
        </member>
        <member name="M:ManagedSteam.Steam.Initialize">
            <summary>
            Initializes the native dll and the managed wrapper. Use the returned class to
            communicate with the steam API. Can only be used once.
            </summary>
            <exception cref="T:ManagedSteam.Exceptions.AlreadyLoadedException"></exception>
            <exception cref="T:ManagedSteam.Exceptions.SteamInitializeFailedException"></exception>
            <exception cref="T:ManagedSteam.Exceptions.SteamInterfaceInitializeFailedException"></exception>
            <exception cref="T:System.InvalidOperationException">One instance of the Steam class already exists.</exception>
            <returns>The instance of the Steam class to be used for all communication with the Steamworks API.</returns>
        </member>
        <member name="M:ManagedSteam.Steam.Shutdown">
            <summary>
            Call this right before your game shuts down. This performs cleanup of managed and native resources.
            </summary>
            <remarks>No parts of the API will be usable after this.</remarks>
        </member>
        <member name="M:ManagedSteam.Steam.Update">
            <summary>
            This method dispatches all events. It needs to be run at regular intervals (like every frame).
            </summary>
        </member>
        <member name="M:ManagedSteam.Steam.ReportException(System.Exception)">
            <summary>
            Shall be called by other classes that have callbacks from native code, and therefore have 
            to buffer exceptions.
            Will invoke the exception event with the specified exception as parameter.
            </summary>
        </member>
        <member name="M:ManagedSteam.Steam.ReleaseManagedResources">
            <summary>
            This will release all the managed resources. The native dll is still loaded and usable.
            Just call Initialize to be able to communicate with steam again.
            This method is only intended to be used if the API is used in Unity's editor during
            development.
            </summary>
        </member>
        <member name="M:ManagedSteam.Steam.CheckIfUsable">
            <summary>
            This method does some general checks to see if the current instance can communicate with the native dll.
            </summary>
        </member>
        <member name="P:ManagedSteam.Steam.Instance">
            <summary>
            The active instance that can communicate with the Steamworks API.
            </summary>
        </member>
        <member name="P:ManagedSteam.Steam.IsAvailable">
            <summary>
            Returns true if communication with the steam API is possible
            </summary>
        </member>
        <member name="P:ManagedSteam.Steam.AppID">
            <summary>
            The application id of the game. Only valid if IsAvailable is true
            </summary>
        </member>
        <member name="E:ManagedSteam.Steam.ExceptionThrown">
            <summary>
            This event is raised if any exceptions are thrown directly or indirectly while in native code
            </summary>
        </member>
    </members>
</doc>
